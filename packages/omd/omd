#!/usr/bin/python3
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
#
#       U  ___ u  __  __   ____
#        \/"_ \/U|' \/ '|u|  _"\
#        | | | |\| |\/| |/| | | |
#    .-,_| |_| | | |  | |U| |_| |\
#     \_)-\___/  |_|  |_| |____/ u
#          \\   <<,-,,-.   |||_
#         (__)   (./  \.) (__)_)
#
# This file is part of OMD - The Open Monitoring Distribution.
# The official homepage is at <https://labs.consol.de/omd/>.
#
# OMD  is  free software;  you  can  redistribute it  and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the  Free Software  Foundation  in  version 2.  OMD  is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# ails.  You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

OMD_VERSION = "5.40-labs-edition"

import os
import sys
sys.path.append("/omd/versions/%s/lib/python" % OMD_VERSION)

if not os.path.exists("/omd/versions/%s" % OMD_VERSION):
    sys.stderr.write("Error: this binary is omd version %s, but this version is not installed: /omd/versions/%s\n"
                     % (OMD_VERSION, OMD_VERSION))
    sys.exit(3)

import abc
import argparse
import grp
import psutil
import pwd
import re
import shutil
import stat
import string
import subprocess
import time
import tty
import typing

# Some global variables
opt_verbose     = False
opt_interactive = False
opt_force       = False
opt_help        = False
opt_version     = None

# Global variables, that are *always* present as soon as we deal with
# one specific site. They are set by set_site_globals()
g_sitename      = None # "mysite"
g_sitedir       = None # "/omd/sites/mysite"
g_site_conf     = None # { "CORE" : "naemon", ... } (contents of etc/omd/site.conf plus defaults from hooks)

# set default file modes and mask
g_dir_mode      = 0o755
g_file_mode     = 0o644
os.umask(0o022);

#   .--Logging-------------------------------------------------------------.
#   |                _                      _                              |
#   |               | |    ___   __ _  __ _(_)_ __   __ _                  |
#   |               | |   / _ \ / _` |/ _` | | '_ \ / _` |                 |
#   |               | |__| (_) | (_| | (_| | | | | | (_| |                 |
#   |               |_____\___/ \__, |\__, |_|_| |_|\__, |                 |
#   |                           |___/ |___/         |___/                  |
#   +----------------------------------------------------------------------+
#   | Helper functions for output on the TTY                               |
#   '----------------------------------------------------------------------'

# colored output, if stdout is a tty
on_tty = sys.stdout.isatty()

if on_tty:
    tty_black     = '\033[30m'
    tty_red       = '\033[31m'
    tty_green     = '\033[32m'
    tty_yellow    = '\033[33m'
    tty_blue      = '\033[34m'
    tty_magenta   = '\033[35m'
    tty_cyan      = '\033[36m'
    tty_white     = '\033[37m'
    tty_bgblack   = '\033[40m'
    tty_bgred     = '\033[41m'
    tty_bggreen   = '\033[42m'
    tty_bgyellow  = '\033[43m'
    tty_bgblue    = '\033[44m'
    tty_bgmagenta = '\033[45m'
    tty_bgcyan    = '\033[46m'
    tty_bgwhite   = '\033[47m'
    tty_bold      = '\033[1m'
    tty_underline = '\033[4m'
    tty_normal    = '\033[0m'
    tty_ok        = tty_green + tty_bold + 'OK' + tty_normal
    tty_error     = tty_red + tty_bold + 'ERROR' + tty_normal
else:
    tty_black     = ''
    tty_red       = ''
    tty_green     = ''
    tty_yellow    = ''
    tty_blue      = ''
    tty_magenta   = ''
    tty_cyan      = ''
    tty_white     = ''
    tty_bgred     = ''
    tty_bggreen   = ''
    tty_bgyellow  = ''
    tty_bgblue    = ''
    tty_bgmagenta = ''
    tty_bgcyan    = ''
    tty_bold      = ''
    tty_underline = ''
    tty_normal    = ''
    tty_ok        = 'OK'
    tty_error     = 'ERROR'

def ok():
    sys.stdout.write(tty_ok + "\n")

def bail_out(message):
    sys.exit(message)

# Symbols for update
good  = " " + tty_green +  tty_bold + "*" + tty_normal
warn  = " " + tty_bgyellow + tty_black + tty_bold + "!" + tty_normal
error = " " + tty_bgred +  tty_white +   tty_bold + "!" + tty_normal

# Is used to duplicate output from stdout/stderr to a logfiles. This
# is e.g. used during "omd update" to have a chance to analyze errors
# during past updates
class Log(object):
    def __init__(self, fd, logfile):
        self.log = open(logfile, 'a')
        self.fd  = fd

        if self.fd == 1:
            self.orig  = sys.stdout
            sys.stdout = self
        else:
            self.orig  = sys.stderr
            sys.stderr = self

        self.color_replace = re.compile("\033\[\d{1,2}m", re.UNICODE)

    def __del__(self):
        if self.fd == 1:
            sys.stdout = self.orig
        else:
            sys.stderr = self.orig
        self.log.close()

    def write(self, data):
        self.orig.write(data)
        self.log.write(self.color_replace.sub('', data))

    def flush(self):
        self.log.flush()
        self.orig.flush()

g_stdout_log = None
g_stderr_log = None

def start_logging(logfile):
    global g_stdout_log, g_stderr_log
    g_stdout_log = Log(1, logfile)
    g_stderr_log = Log(2, logfile)

def stop_logging():
    global g_stdout_log, g_stderr_log
    g_stdout_log = None
    g_stderr_log = None

def show_success(exit_code):
    if exit_code == True or exit_code == 0:
        ok()
    else:
        sys.stdout.write(tty_error + "\n")
    return exit_code


#.
#   .--Dialog--------------------------------------------------------------.
#   |                     ____  _       _                                  |
#   |                    |  _ \(_) __ _| | ___   __ _                      |
#   |                    | | | | |/ _` | |/ _ \ / _` |                     |
#   |                    | |_| | | (_| | | (_) | (_| |                     |
#   |                    |____/|_|\__,_|_|\___/ \__, |                     |
#   |                                           |___/                      |
#   +----------------------------------------------------------------------+
#   |  Wrapper functions for interactive dialogs using the dialog cmd tool |
#   '----------------------------------------------------------------------'

def run_dialog(args):
    env = {
        "TERM": getenv("TERM", "linux"),
        "LANG": "de_DE.UTF-8"
    }
    p = subprocess.Popen(["dialog", "--shadow", "--no-mouse"] + args, env = env, stderr = subprocess.PIPE)
    response = p.stderr.read()
    rc = 0 == os.waitpid(p.pid, 0)[1]
    if not rc and response.decode() != "":
        bail_out(tty_error + ": " + response.decode())
    return rc, response.decode('utf-8')


def dialog_menu(title, text, choices, defvalue, oktext, canceltext):
    args = [ "--ok-label", oktext, "--cancel-label", canceltext ]
    if defvalue != None:
        args += [ "--default-item", defvalue ]
    args += [ "--title", title, "--menu", text, "0", "0", "0" ] # "20", "60", "17" ]
    for text, value in choices:
        args += [ text, value ]
    return run_dialog(args)


def dialog_regex(title, text, regex, value, oktext, canceltext):
    while True:
        args = [ "--ok-label", oktext, "--cancel-label", canceltext,
                 "--title", title, "--inputbox", text, "0", "0", value ]
        change, new_value = run_dialog(args)
        if not change:
            return False, value
        elif not regex.match(new_value):
            dialog_message("Invalid value. Please try again.")
            value = new_value
        else:
            return True, new_value


def dialog_yesno(text, yeslabel = "yes", nolabel = "no"):
    state, response = run_dialog(["--colors", "--no-collapse", "--yes-label", yeslabel, "--no-label", nolabel, "--yesno", text, "0", "0"])
    return state


def dialog_message(text, buttonlabel="OK"):
    run_dialog(["--ok-label", buttonlabel, "--msgbox", text, "0", "0"])


def user_confirms(title, message, relpath, yes_choice, yes_text, no_choice, no_text):
    # Handle non-interactive mode
    if opt_conflict == "abort":
        bail_out("Update aborted.")
    elif opt_conflict == "install":
        return False
    elif opt_conflict == "keepold":
        return True

    user_path = g_sitedir + "/" + relpath
    options = [ (yes_choice, yes_text),
                (no_choice,  no_text),
                ("shell",    "Open a shell for looking around"),
                ("abort",    "Stop here and abort update!")]
    while True:
        choice = ask_user_choices(title, message, options)
        if choice == "abort":
            bail_out("Update aborted.")
        elif choice == "shell":
            thedir = os.path.dirname(user_path)
            sys.stdout.write("\n Starting BASH. Type CTRL-D to continue.\n\n")
            os.system("cd '%s' ; bash -i" % thedir)
        else:
            return choice == yes_choice


def wrap_text(text, width):
    def fillup(line, width):
        if len(line) < width:
            line += " " * (width - len(line))
        return line

    def justify(line, width):
        need_spaces = float(width - len(line))
        spaces = float(line.count(' '))
        newline = ""
        x = 0.0
        s = 0.0
        words = line.split()
        newline = words[0]
        for word in words[1:]:
            newline += ' '
            x += 1.0
            if s/x < need_spaces / spaces:
                newline += ' '
                s += 1
            newline += word
        return newline

    wrapped = []
    line = ""
    col = 0
    for word in text.split():
        netto = len(word)
        if line != "" and netto + col + 1 > width:
            wrapped.append(justify(line, width))
            col = 0
            line = ""
        if line != "":
            line += ' '
            col += 1
        line += word
        col += netto
    if line != "":
        wrapped.append(fillup(line, width))

    # remove trailing empty lines
    while wrapped[-1].strip() == "":
        wrapped = wrapped[:-1]
    return wrapped

def getch():
    import termios
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(sys.stdin.fileno())
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
    if ord(ch) == 3:
        raise KeyboardInterrupt()
    return ch


def ask_user_choices(title, message, choices):
    sys.stdout.write("\n")
    def pl(line):
        sys.stdout.write(" %s %-76s %s\n" % (tty_bgcyan + tty_white, line, tty_normal))
    pl("")
    sys.stdout.write(" %s %-76s %s\n" % (tty_bgcyan + tty_white + tty_bold, title, tty_normal))
    for line in wrap_text(message, 76):
        pl(line)
    pl("")
    chars = []
    empty_line = " %s%-78s%s\n" % (tty_bgblue + tty_white, "", tty_normal)
    sys.stdout.write(empty_line)
    for choice, title in choices:
        sys.stdout.write(" %s %s%s%s%-10s %-65s%s\n" %
                (tty_bgblue + tty_white, tty_bold, choice[0],
                 tty_normal + tty_bgblue + tty_white, choice[1:], title, tty_normal))
        for c in choice:
            if c.lower() not in chars:
                chars.append(c)
                break
    sys.stdout.write(empty_line)

    choicetxt = (tty_bold + tty_magenta + "/").join([(tty_bold + tty_white + char + tty_normal + tty_bgmagenta) for (char, (c,t)) in zip(chars, choices)])
    l = len(choices) * 2 - 1
    sys.stdout.write(" %s %s" % (tty_bgmagenta, choicetxt))
    sys.stdout.write(" ==> %s   %s" % (tty_bgred, tty_bgmagenta))
    sys.stdout.write(" " * (69 - l))
    sys.stdout.write("\b" * (71 - l))
    sys.stdout.write(tty_normal)
    while True:
        a = getch()
        for char, (choice, title) in zip(chars, choices):
            if a == char:
                sys.stdout.write(tty_bold + tty_bgred + tty_white + a + tty_normal + "\n\n")
                return choice


#.
#   .--Users/Groups--------------------------------------------------------.
#   |     _   _                      ______                                |
#   |    | | | |___  ___ _ __ ___   / / ___|_ __ ___  _   _ _ __  ___      |
#   |    | | | / __|/ _ \ '__/ __| / / |  _| '__/ _ \| | | | '_ \/ __|     |
#   |    | |_| \__ \  __/ |  \__ \/ /| |_| | | | (_) | |_| | |_) \__ \     |
#   |     \___/|___/\___|_|  |___/_/  \____|_|  \___/ \__,_| .__/|___/     |
#   |                                                      |_|             |
#   +----------------------------------------------------------------------+
#   |  Helper functions for dealing with Linux users and groups            |
#   '----------------------------------------------------------------------'

def find_processes_of_user(username):
    try:
        return os.popen("pgrep -u '%s'" % username).read().split()
    except Exception:
        return []

def groupdel(groupname):
    os.system("groupdel " + groupname + " >/dev/null 2>&1")
    # -f is required on fc26 which fails otherwise: groupdel: cannot remove the primary group of user
    # but -f is not available on every system
    os.system("groupdel -f " + groupname + " >/dev/null 2>&1")

def groupadd(groupname, gid = None):
    cmd = "groupadd "
    if gid != None:
        cmd += "-g %d " % int(gid)
    else:
        cmd += "-r "
    cmd += groupname

    if 0 != os.system(cmd):
        bail_out(tty_error + ": Cannot create group for site user.")

def useradd(sitename, uid = None, gid = None):
    # Create user for running site 'name'
    groupadd(sitename, gid)
    useradd_options = g_info["USERADD_OPTIONS"]
    if uid != None:
        useradd_options += " -u %d" % int(uid)
    if 0 != os.system("useradd %s -r -d '%s' -c 'OMD site %s' -g %s -G omd %s -s /bin/bash" % \
                      (useradd_options, site_dir(sitename), sitename, sitename, sitename)):
        groupdel(sitename)
        bail_out(tty_error + ": Error creating site user.")

    # Add Apache to new group. It needs to be able to write in to the
    # command pipe and possible other stuff
    add_user_to_group(g_info["APACHE_USER"], sitename)

def add_user_to_group(user, group):
    cmd = g_info["ADD_USER_TO_GROUP"] % {"user": user, "group" : group}
    return os.system(cmd + " >/dev/null") == 0

def userdel(name):
    os.system("userdel -r %s >/dev/null 2>&1" % name)
    # On some OSes (e.g. debian) the group is automatically removed if
    # it bears the same name as the user. So first check for the group.
    if group_exists(name):
        groupdel(name)

def user_by_id(id):
    try:
        return pwd.getpwuid(id)
    except Exception:
        return None

def user_id(name):
    try:
        return pwd.getpwnam(name).pw_uid
    except Exception:
        return False

def user_exists(name):
    try:
        pwd.getpwnam(name)
        return True
    except Exception:
        return False

def user_has_group(user, group):
    try:
        u = user_by_id(user_id(user))
        g = group_by_id(u.pw_gid)
        if g.gr_name == group:
            return True
        g = group_by_id(group_id(group))
        if user in g.gr_mem:
            return True;
    except Exception:
        return False


def group_exists(name):
    try:
        grp.getgrnam(name)
        return True
    except Exception:
        return False


def group_by_id(id):
    try:
        return grp.getgrgid(id)
    except Exception:
        return None

def group_id(name):
    try:
        g = grp.getgrnam(name)
        return g.gr_gid
    except Exception:
        return None

def user_logged_in(name):
    # Check, if processes of named user are existing
    return os.system("ps --no-headers --user '%s' >/dev/null 2>&1" % name) == 0

def user_verify(name, allow_populated=False):

    if not user_exists(name):
        bail_out(tty_error + ": user %s does not exist" % name )

    user = user_by_id(user_id(name))
    if user.pw_dir != site_dir(name):
        bail_out(tty_error + ": Wrong home directory for user %s, must be %s" % ( name, site_dir(name) ) )

    if not os.path.exists(site_dir(name)):
        bail_out(tty_error + ": home directory for user %s (%s) does not exist" % ( name, site_dir(name) ) )

    if not allow_populated and os.path.exists(site_dir(name) + "/version"):
        bail_out(tty_error + ": home directory for user %s (%s) must be empty" % ( name, site_dir(name) ) )

    if not file_owner_verify(site_dir(name), user.pw_uid, user.pw_gid):
        bail_out(tty_error + ": home directory (%s) is not owned by user %s and group %s" % ( site_dir(name), name, name ) )

    group = group_by_id(user.pw_gid)
    if group is None or group.gr_name != name:
        bail_out(tty_error + ": primary group for siteuser must be %s" % name )

    if not user_has_group(g_info["APACHE_USER"], name):
        bail_out(tty_error + ": apache user %s must be member of group %s" % ( g_info["APACHE_USER"], name ) )

    if not user_has_group(name, "omd"):
        bail_out(tty_error + ": siteuser must be member of group omd" )

    return True

def switch_to_site_user():
    p = pwd.getpwnam(g_sitename)
    uid = p.pw_uid
    gid = p.pw_gid
    os.chdir(p.pw_dir)
    os.setgid(gid)

    # Darn. The site user might have been put into further groups.
    # This is e.g. needed if you want to access the livestatus socket
    # from one site by another. We make use of the "id" command here.
    os.setgroups(groups_of(g_sitename))
    os.setuid(uid)

def groups_of(username):
    return list(map(int, os.popen("id -G '%s'" % username).read().split()))



#.
#   .--Sites---------------------------------------------------------------.
#   |                        ____  _ _                                     |
#   |                       / ___|(_) |_ ___  ___                          |
#   |                       \___ \| | __/ _ \/ __|                         |
#   |                        ___) | | ||  __/\__ \                         |
#   |                       |____/|_|\__\___||___/                         |
#   |                                                                      |
#   +----------------------------------------------------------------------+
#   |  Helper functions for dealing with sites                             |
#   '----------------------------------------------------------------------'

# Sets all site global variables except g_sitename - which must already be set.
def set_site_globals():
    global g_sitedir
    g_sitedir = site_dir(g_sitename)
    load_site_conf(skipMissing=True)

def site_dir(sitename):
    return "/omd/sites/" + sitename

def tmp_dir(sitename):
    return "/omd/sites/%s/tmp" % sitename

def site_name():
        return pwd.getpwuid(os.getuid()).pw_name

def site_exists(sitename):
    return os.path.exists(site_dir(sitename))

def all_sites():
    l = [ s for s in os.listdir("/omd/sites") if os.path.isdir(os.path.join("/omd/sites/", s)) ]
    l.sort()
    return l

# Check if site is completely stopped
def site_is_stopped(sitename):
    if am_root():
        return call_as_forked_site_user(site_is_stopped, [sitename], {}) == 1

    return check_status(sitename, False) == 1

def site_is_running(sitename):
    if am_root():
        return call_as_forked_site_user(site_is_stopped, [sitename], {}) == 0

    return check_status(sitename, False) == 0

def site_is_empty(sitename):
    sitedir = site_dir(sitename)
    for entry in os.listdir(sitedir):
        if entry not in [ '.', '..' ]:
            return False
    return True

# Determines wether a specific site is set to autostart. Note that
# this needs to be called from a non-site-specific context and
# can there not use the g_site... variables.
def site_autostart(sitename):
    config = parse_site_conf(sitename)
    return config.get('AUTOSTART', 'on') == 'on'

# The version of a site is solely determined by the
# link ~SITE/version
def site_version(sitename):
    version_link = site_dir(sitename) + "/version"
    try:
        version = os.readlink(version_link).split("/")[-1]
        return version
    except Exception:
        return None

def start_site(sitename):
    prepare_and_populate_tmpfs(sitename)
    call_init_scripts(sitename, "start")

def stop_site(sitename):
    call_init_scripts(sitename, "stop")



#.
#   .--Skeleton------------------------------------------------------------.
#   |                ____  _        _      _                               |
#   |               / ___|| | _____| | ___| |_ ___  _ __                   |
#   |               \___ \| |/ / _ \ |/ _ \ __/ _ \| '_ \                  |
#   |                ___) |   <  __/ |  __/ || (_) | | | |                 |
#   |               |____/|_|\_\___|_|\___|\__\___/|_| |_|                 |
#   |                                                                      |
#   +----------------------------------------------------------------------+
#   |  Deal with file owners, permissions and the the skel hierarchy       |
#   '----------------------------------------------------------------------'

def read_skel_permissions():
    global g_skel_permissions
    g_skel_permissions = load_skel_permissions(OMD_VERSION)
    if not g_skel_permissions:
        file_path = omd_root() + "/share/omd/skel.permissions"
        bail_out(tty_error + ": %s is missing or currupted." % file_path)

def load_skel_permissions(version):
    file_path = "/omd/versions/%s/share/omd/skel.permissions" % version
    return load_skel_permissions_for_path(file_path)

def load_skel_permissions_for_path(file_path):
    perms = {}
    try:
        for line in open(file_path):
            line = line.strip()
            if line == "" or line[0] == "#":
                continue
            path, perm = line.split()
            mode = int(perm, 8)
            perms[path] = mode
        return perms
    except Exception:
        return None

def get_skel_permissions(version, perms, relpath, skel_path = None):
    if not skel_path:
        skel_path = "/omd/versions/%s/skel" % (version)
    try:
        return perms[relpath]
    except Exception:
        return get_file_permissions("%s/%s" % (skel_path, relpath))

def get_file_permissions(path):
    try:
        return os.stat(path).st_mode & 0o07777
    except Exception:
        return 0

def get_file_owner(path):
    try:
        return pwd.getpwuid(os.stat(path).st_uid)[0]
    except Exception:
        return None

def create_version_symlink(sitename, version):
    linkname = site_dir(sitename) + "/version"
    if os.path.lexists(linkname):
        os.remove(linkname)
    os.symlink("../../versions/%s" % OMD_VERSION, linkname)


def calculate_admin_password(options):
    return options.admin_password or random_password()


def set_admin_password(pw):
    p = subprocess.Popen(["%s/bin/set_admin_password" % g_sitedir, pw], stderr = subprocess.PIPE, stdout = subprocess.PIPE)
    response = p.stderr.read()
    return 0 == os.waitpid(p.pid, 0)[1], response


def file_owner_verify(path, user_id, group_id):
    try:
        s = os.stat(path)
        if s.st_uid != user_id or s.st_gid != group_id:
            return False
    except Exception:
        return False
    return True

def create_skeleton_files(sitename, dir):
    read_skel_permissions()
    sitedir = site_dir(sitename)
    replacements = {
        "###SITE###" : sitename,
        "###ROOT###" : sitedir,
    }
    # Hack: exclude tmp if dir is '.'
    exclude_tmp = dir == "."
    skelroot = omd_root() + "/skel"
    os.chdir(skelroot)  # make relative paths
    for dirpath, dirnames, filenames in os.walk(dir):
        if dirpath.startswith("./"):
            dirpath = dirpath[2:]
        for entry in dirnames + filenames:
            if exclude_tmp:
                if dirpath == "." and entry == "tmp":
                    continue
                if dirpath == "tmp" or dirpath.startswith("tmp/"):
                    continue
            if not os.path.exists(sitedir + "/" + dirpath):
                create_skeleton_file(skelroot, sitedir, dirpath, replacements)
            create_skeleton_file(skelroot, sitedir, dirpath + "/" + entry, replacements)

def delete_user_file(user_path):
    if not os.path.islink(user_path) and os.path.isdir(user_path):
        shutil.rmtree(user_path)
    else:
        os.remove(user_path)

def delete_directory_contents(d):
    for f in os.listdir(d):
        delete_user_file(d + '/' + f)

def create_skeleton_file(skelbase, userbase, relpath, replacements):
    skel_path = skelbase + "/" + relpath
    user_path = userbase + "/" + relpath

    # Remove old version, if existing (needed during update)
    if (os.path.islink(user_path) and os.path.lexists(user_path)) or os.path.exists(user_path):
        if relpath in [ './bin', './include', './lib', './share', './version' ]:
            bail_out(tty_error + " %s would overwrite base symlink %s, check your skeleton folder." % (skel_path, user_path))
        delete_user_file(user_path)

    # Create directories, symlinks and files
    if os.path.islink(skel_path):
        os.symlink(os.readlink(skel_path), user_path)
    elif os.path.isdir(skel_path):
        os.makedirs(user_path)
    else:
        open(user_path, "wb").write(replace_tags(open(skel_path, "rb").read(), replacements))

    if not os.path.islink(skel_path):
        mode = g_skel_permissions.get(relpath)
        if mode is None:
            if os.path.isdir(skel_path):
                mode = g_dir_mode
            else:
                mode = g_file_mode
        os.chmod(user_path, mode)


def chown_tree(dir, user):
    uid = pwd.getpwnam(user).pw_uid
    gid = pwd.getpwnam(user).pw_gid
    os.chown(dir, uid, gid)
    for dirpath, dirnames, filenames in os.walk(dir):
        for entry in dirnames + filenames:
            os.lchown(dirpath + "/" + entry, uid, gid)


def try_chown(filename, user):
    if os.path.exists(filename):
        try:
            uid = pwd.getpwnam(user).pw_uid
            gid = pwd.getpwnam(user).pw_gid
            os.chown(filename, uid, gid)
        except Exception as e:
            sys.stderr.write("Cannot chown %s to %s: %s\n" % (filename, user, e))


def instantiate_skel(path):
    try:
        t = open(path, "rb").read()
        replacements = {
            "###SITE###" : g_sitename,
            "###ROOT###" : g_sitedir,
        }
        for hook_name in g_site_conf:
            replacements["###CONFIG_%s###" % hook_name] = g_site_conf[hook_name]
        return replace_tags(t, replacements)
    except Exception:
        return "" # e.g. due to permission error


# Walks all files in the skeleton dir to execute a function for each file
# The given handler is called with the provided args. Additionally the relative
# path of the file to handle is handed over in the 'relpath' parameter.

# When called with a path in 'exclude_if_in' then paths existing relative to
# that are skipped. This is used for a second run during the update-process: to handle
# files that have vanished in the new version.

# The option 'relbase' is optional. It can contain a relative path which can be used
# as base for the walk instead of walking the whole tree.

# The function returns a set of already handled files.
def walk_skel(root, handler, args, kwargs, depth_first, exclude_if_in = None, relbase = '.', filter = None):
    import traceback
    os.chdir(root)

    # Note: os.walk first finds level 1 directories, then deeper
    # layers. If we need a real depth search instead, where we first
    # handle deep directories and files, then the top level ones.
    walk_entries = list(os.walk(relbase))
    if depth_first:
        walk_entries.reverse()

    for dirpath, dirnames, filenames in walk_entries:
        if dirpath.startswith("./"):
            dirpath = dirpath[2:]
        if dirpath.startswith("tmp"):
            continue

        # In depth first search first handle files, then directories
        if depth_first:
            entries = filenames + dirnames
        else:
            entries = dirnames + filenames
        for entry in entries:
            path = dirpath + "/" + entry
            if path.startswith("./"):
                path = path[2:]

            if exclude_if_in and os.path.exists(exclude_if_in + "/" + path):
                continue

            if filter and not path in filter:
                continue

            todo = True
            while todo:
                try:
                    handler(path, *args, **kwargs)
                    todo = False
                except Exception as e:
                    todo = False
                    sys.stderr.write(error * 40 + "\n")
                    sys.stderr.write(error + " Exception      %s\n" % (path))
                    sys.stderr.write(error + " " + traceback.format_exc().replace('\n', "\n" + error + " ") + "\n")
                    sys.stderr.write(error * 40 + "\n")

                    # If running in interactive mode ask the user to terminate or retry
                    # In case of non interactive mode just throw the exception
                    if opt_conflict == 'ask':
                        options = [
                            ("retry",    "Retry the operation"),
                            ("continue", "Continue with next files"),
                            ("shell",    "Open a shell for looking around"),
                            ("abort",    "Stop here and abort update!")
                        ]
                        ask_again = True
                        while ask_again:
                            ask_again = False
                            choice = ask_user_choices(
                                'Problem occured',
                                'We detected an exception (printed above). You have the '
                                'chance to fix things and retry the operation now.',
                                options
                            )
                            if choice == 'abort':
                                bail_out("Update aborted.")
                            elif choice == "shell":
                                sys.stdout.write("\n Starting BASH. Type CTRL-D to continue.\n\n")
                                os.system("cd '%s' ; bash -i" % g_sitedir)
                                ask_again = True # Try again
                            elif choice == 'retry':
                                todo = True # Try again


#.
#   .--omd update----------------------------------------------------------.
#   |                           _                   _       _              |
#   |        ___  _ __ ___   __| |  _   _ _ __   __| | __ _| |_ ___        |
#   |       / _ \| '_ ` _ \ / _` | | | | | '_ \ / _` |/ _` | __/ _ \       |
#   |      | (_) | | | | | | (_| | | |_| | |_) | (_| | (_| | ||  __/       |
#   |       \___/|_| |_| |_|\__,_|  \__,_| .__/ \__,_|\__,_|\__\___|       |
#   |                                    |_|                               |
#   +----------------------------------------------------------------------+
#   |  Complex handling of skeleton and user files during update           |
#   '----------------------------------------------------------------------'

# Change site specific information in files originally create from
# skeleton files. Skip files below tmp/
def patch_skeleton_files(old, new, skelroot=None):
    import traceback
    if not skelroot:
        skelroot = omd_root() + "/skel"
    os.chdir(skelroot)  # make relative paths
    for dirpath, dirnames, filenames in os.walk("."):
        if dirpath.startswith("./"):
            dirpath = dirpath[2:]
        targetdir = site_dir(new) + "/" + dirpath
        if targetdir.startswith(tmp_dir(new)):
            continue # Skip files below tmp
        for fn in filenames:
            src = dirpath + "/" + fn
            dst = targetdir + "/" + fn
            if os.path.isfile(src) and not os.path.islink(src) \
                and os.path.exists(dst): # not deleted by user
                try:
                    patch_template_file(src, dst, old, new)
                except Exception as e:
                    traceback.print_exc(file=sys.stdout)
                    sys.stderr.write("Error patching template file '%s': %s\n" %
                            (dst, e))

def patch_template_file(src, dst, old, new):
    # Create patch from old instantiated skeleton file to new one
    content = open(src, "rb").read()
    for site in [ old, new ]:
        replacements = {
            "###SITE###" : site,
            "###ROOT###" : site_dir(site),
        }
        for hook_name in g_site_conf:
            replacements["###CONFIG_%s###" % hook_name] = g_site_conf[hook_name]
        filename = "%s.skel.%s" % (dst, site)
        open(filename, "wb").write(replace_tags(content, replacements))
        try_chown(filename, new)

    # If old and new skeleton file are identical, then do nothing
    old_orig_path = "%s.skel.%s" % (dst, old)
    new_orig_path = "%s.skel.%s" % (dst, new)
    if open(old_orig_path, "rb").read() == open(new_orig_path, "rb").read():
        os.remove(old_orig_path)
        os.remove(new_orig_path)
        return

    # Now create a patch from old to new and immediately apply on
    # existing - possibly user modified - file.
    patch = "%s/bin/patch" % site_dir(new)
    if not os.path.exists(patch):
        patch = omd_root() + "/bin/patch"
    if not os.path.exists(patch):
        patch = "%s/patch" % os.path.dirname(os.path.realpath(__file__))
    if not os.path.exists(patch):
        patch = "patch"

    result = os.system("diff -u %s %s | %s --force --backup --forward --silent %s" %
            (old_orig_path, new_orig_path, patch, dst))
    try_chown(dst, new)
    try_chown(dst + ".rej", new)
    try_chown(dst + ".orig", new)
    if result == 0:
        sys.stdout.write(good + " Converted      %s\n" % src)
    else:
        # Make conflict resolution interactive - similar to omd update
        options = [
            ( "diff",      "Show conversion patch, that I've tried to apply" ),
            ( "you",       "Show your changes compared with the original default version" ),
            ( "edit",      "Edit half-converted file (watch out for >>>> and <<<<)" ),
            ( "vimdiff",   "Edit files with vimdiff to manually resolve conflicts" ),
            ( "try again", "Edit your original file and try again"),
            ( "keep",      "Keep half-converted version of the file" ),
            ( "restore",   "Restore your original version of the file" ),
            ( "install",   "Install the default version of the file" ),
            ( "brute",     "Simply replace /%s/ with /%s/ in that file" % (old, new)),
            ( "shell",     "Open a shell for looking around" ),
            ( "abort",     "Stop here and abort!" ),
        ]

        while True:
            if opt_conflict in [ "abort", "install" ]:
                choice = opt_conflict
            elif opt_conflict == "keepold":
                choice = "restore"
            else:
                choice = ask_user_choices("Conflicts in " + src + "!",
                   "I've tried to merge your changes with the renaming of %s into %s.\n"
                   "Unfortunately there are conflicts with your changes. \n"
                   "You have the following options: " %
                    ( old, new ), options)

            if choice == "abort":
                bail_out("Renaming aborted.")
            elif choice == "keep":
                break
            elif choice == "edit":
                os.system("%s '%s'" % (get_editor(), dst))
            elif choice == "diff":
                os.system("diff -u %s %s%s" % (old_orig_path, new_orig_path, pipe_pager()))
            elif choice == "vimdiff":
                os.system("vimdiff %s %s" % (old_orig_path, new_orig_path))
                if user_confirms("Is the conflict at " + old_orig_path + " resolved?",
                        "Continue or start over",
                        old_orig_path,
                        "yes", "Continue",
                        "no", "Start over"):
                    break
            elif choice == "brute":
                os.system("sed 's@/%s/@/%s/@g' %s.orig > %s" % (old, new, dst, dst))
                changed = len([ l for l in os.popen("diff %s.orig %s" % (dst, dst)).readlines()
                  if l.startswith(">") ])
                if changed == 0:
                    sys.stdout.write("Found no matching line.\n")
                else:
                    sys.stdout.write("Did brute-force replace, changed %s%d%s lines:\n" %
                      (tty_bold, changed, tty_normal))
                    os.system("diff -u %s.orig %s" % (dst, dst))
                    break
            elif choice == "you":
                os.system("pwd ; diff -u %s %s.orig%s" % (old_orig_path, dst, pipe_pager()))
            elif choice == "restore":
                os.rename(dst + ".orig", dst)
                if opt_conflict == "keepold":
                    sys.stdout.write(warn + " Restored file  %s (forced restore)\n" % src)
                else:
                    sys.stdout.write(good + " Restored file  %s\n" % src)
                break
            elif choice == "install":
                os.rename(new_orig_path, dst)
                if opt_conflict == "install":
                    sys.stdout.write(warn + " Installed file %s (forced default install)\n" % src)
                else:
                    sys.stdout.write(good + " Installed file %s\n" % src)
                break
            elif choice == "shell":
                relname = src.split("/")[-1]
                sys.stdout.write(" %-35s the half-converted file\n" % (relname,))
                sys.stdout.write(" %-35s your original version\n" % (relname + ".orig"))
                sys.stdout.write(" %-35s the failed parts of the patch\n" % (relname + ".rej"))
                sys.stdout.write(" %-35s default version with the old site name\n" % (relname + ".skel.%s" % old))
                sys.stdout.write(" %-35s default version with the new site name\n" % (relname + ".skel.%s" % new))

                sys.stdout.write("\n Starting BASH. Type CTRL-D to continue.\n\n")
                thedir = "/".join(dst.split("/")[:-1])
                os.system("su - %s -c 'cd %s ; bash -i'" % (new, thedir))

    # remove unnecessary files
    try:
        os.remove(dst + ".skel." + old)
        os.remove(dst + ".skel." + new)
        os.remove(dst + ".orig")
        os.remove(dst + ".rej")
    except Exception:
        pass

# Try to merge changes from old->new version and
# old->user version
def merge_update_file(relpath, userdir, old_version, new_version, skel_path, dry_run=False):
    fn = tty_bold + relpath + tty_normal

    replacements = {
        "###SITE###" : g_sitename,
        "###ROOT###" : g_sitedir,
    }
    for hook_name in g_site_conf:
        replacements["###CONFIG_%s###" % hook_name] = g_site_conf[hook_name]
    user_path = userdir + "/" + relpath
    open(user_path, "rb").read()
    permissions = os.stat(user_path).st_mode

    def try_merge():
        for version in [ old_version, new_version ]:
            p = "%s/%s" % (skel_path, relpath)
            if version == new_version:
                p = "/omd/versions/%s/skel/%s" % (new_version, relpath)
            while True:
                try:
                    skel_content = open(p, "rb").read()
                    break
                except Exception as e:
                    # Do not ask the user in non-interactive mode.
                    if dry_run:
                        print_conflict(p, ("skeleton file of version %s not readable" % (version)))
                        if opt_verbose:
                            print("%s\n" % e)
                    elif opt_conflict in [ "abort", "install" ]:
                        bail_out(tty_error + ": Skeleton file '%s' of version %s not readable." % (p, version))
                    elif opt_conflict == "keepold" or not user_confirms("Skeleton file of version %s not readable" % version,
                        "The file '%s' is not readable for the site user. "
                        "This is most probably due a bug in release 0.42. "
                        "You can either fix that problem by making the file "
                        "readable with doing as root: chmod +r '%s' "
                        "or assume the file as empty. In that case you might "
                        "damage your configuration file "
                        "in case you have made changes to it in your site. What shall we do?" %
                        (p, p),
                        relpath,
                        "retry", "Retry reading the file (after you've fixed it)",
                        "ignore", "Assume the file to be empty"):
                        skel_content = ""
                        break
            open("%s-%s" % (user_path, version), "wb").write(replace_tags(skel_content, replacements))
        version_patch = os.popen("diff -u %s-%s %s-%s" % (user_path, old_version, user_path, new_version)).read()

        # First try to merge the changes in the version into the users' file
        p = subprocess.Popen("PATH=/omd/versions/default/bin:$PATH patch --force --backup --forward --silent --merge --ignore-whitespace %s" % (user_path), shell=True, stdin = subprocess.PIPE, stdout = subprocess.PIPE, stderr = subprocess.PIPE)
        out, errs = p.communicate(str.encode(version_patch), timeout=30)
        status = p.wait()
        if status:
            return status / 256, out, errs
        else:
            return 0, out, errs

    def clean_local_temp_files():
        # Clean up temporary files
        for p in [ "%s-%s" % (user_path, old_version),
                   "%s-%s" % (user_path, new_version),
                   "%s.orig" % user_path,
                   "%s.rej" % user_path]:
            try:
                os.remove(p)
            except Exception:
                pass

    merge_res = try_merge()
    if merge_res[0] == 0:
        clean_local_temp_files()
        sys.stdout.write(good + " Merged         %s\n" % fn)
        return

    # No success. Should we try merging the users' changes onto the new file?
    # user_patch = os.popen(
    editor = get_editor()
    reject_file = user_path + ".rej"

    options = [
        ( "diff",      "Show differences between the new default and your version" ),
        ( "you",       "Show your changes compared with the old default version" ),
        ( "new",       "Show what has changed from %s to %s" % (old_version, new_version) ) ]
    if os.path.exists(reject_file): # missing if patch has --merge
        options.append( ( "missing",   "Show which changes from the update have not been merged" ))
    options += [
        ( "edit",      "Edit half-merged file (watch out for >>>>> and <<<<<)"),
        ( "vimdiff",   "Edit files with vimdiff to manually resolve conflicts" ),
        ( "try again", "Edit your original file and try again"),
        ( "keep",      "Keep half-merged version of the file" ),
        ( "restore",   "Restore your original version of the file" ),
        ( "install",   "Install the new default version" ),
        ( "shell",     "Open a shell for looking around" ),
        ( "abort",     "Stop here and abort update!" ),
    ]

    while True:
        if dry_run:
            print_conflict(relpath, "merging updates fails")
            if opt_verbose:
                print("%s\npatch output:\n%s%s" % ("*"*50, merge_res[1].decode(), merge_res[2].decode()))
                print("%s\nyour local changes:\n" % ("*"*50))
                os.system("diff -u %s-%s %s.orig" % (user_path, old_version, user_path))
                print("\n%s\n" % ("*"*50))
            break
        if opt_conflict in [ "install", "abort" ]:
            choice = opt_conflict
        elif opt_conflict == "keepold":
            choice = "restore"
        else:
            choice = ask_user_choices("Conflicts in " + relpath + "!", "I've tried to merge the changes from version %s to %s into %s.\n"
               "Unfortunately there are conflicts with your changes. \n"
               "You have the following options: " %
                    ( old_version, new_version, relpath ), options)

        if choice == "abort":
            bail_out("Update aborted.")
        elif choice == "keep":
            break
        elif choice == "edit":
            os.system("%s '%s'" % (editor, user_path))
        elif choice == "diff":
            os.system("diff -u %s.orig %s-%s%s" % (user_path, user_path, new_version, pipe_pager()))
        elif choice == "vimdiff":
            # restore our version and call vimdiff
            open(user_path, "w").write(open(user_path + ".orig").read())
            os.chmod(user_path, permissions)
            os.system("vimdiff %s %s-%s" % (user_path, user_path, new_version))
            if user_confirms("Is the conflict at " + user_path + " resolved?",
                    "Continue or start over",
                    user_path,
                    "yes", "Continue",
                    "no", "Start over"):
                break
        elif choice == "you":
            os.system("diff -u %s-%s %s.orig%s" % (user_path, old_version, user_path, pipe_pager()))
        elif choice == "new":
            os.system("diff -u %s-%s %s-%s%s" % (user_path, old_version, user_path, new_version, pipe_pager()))
        elif choice == "missing":
            if os.path.exists(reject_file):
                sys.stdout.write(tty_bgblue + tty_white + open(reject_file).read() + tty_normal)
            else:
                sys.stdout.write("File %s not found.\n" % reject_file)

        elif choice == "shell":
            relname = relpath.split("/")[-1]
            sys.stdout.write(" %-25s: the current half-merged file\n" % relname)
            sys.stdout.write(" %-25s: the default version of %s\n" % (relname + "." + old_version, old_version))
            sys.stdout.write(" %-25s: the default version of %s\n" % (relname + "." + new_version, new_version))
            sys.stdout.write(" %-25s: your original version\n" % (relname + ".orig"))
            if os.path.exists(reject_file):
                sys.stdout.write(" %-25s: changes that haven't been merged\n" % relname + ".rej")

            sys.stdout.write("\n Starting BASH. Type CTRL-D to continue.\n\n")
            thedir = "/".join(user_path.split("/")[:-1])
            os.system("cd '%s' ; bash -i" % thedir)
        elif choice == "restore":
            os.rename(user_path + ".orig", user_path)
            os.chmod(user_path, permissions)
            if opt_conflict == "keepold":
                sys.stdout.write(warn + " Restored file  %s (forced restore)\n" % fn)
            else:
                sys.stdout.write(good + " Restored file  %s\n" % fn)
            break
        elif choice == "try again":
            os.rename(user_path + ".orig", user_path)
            os.system("%s '%s'" % (editor, user_path))
            if 0 == try_merge()[0]:
                clean_local_temp_files()
                sys.stdout.write("Successfully merged changes from %s -> %s into %s\n" %
                        (old_version, new_version, fn))
                return
            else:
                sys.stdout.write(" Merge failed again.\n")

        else: # install
            os.rename("%s-%s" % (user_path, new_version), user_path)
            os.chmod(user_path, permissions)
            if opt_conflict == "install":
                sys.stdout.write(warn + " Installed file %s (forced default install)\n" % fn)
            else:
                sys.stdout.write(good + " Installed file %s\n" % fn)
            break

    clean_local_temp_files()

# Compares two files and returns infos wether the file type or contants have changed """
def file_status(source_path, target_path):
    source_type  = filetype(source_path)
    target_type  = filetype(target_path)

    if source_type == "file":
        source_content = file_contents(source_path)

    if target_type == "file":
        target_content = file_contents(target_path)

    changed_type = source_type != target_type
    changed_content = (source_type == "file" \
                       and target_type == "file" \
                       and source_content != target_content) or \
                      (source_type == "link" \
                       and target_type == "link" \
                       and os.readlink(source_path) != os.readlink(target_path))
    changed = changed_type or changed_content
    return (changed_type, changed_content, changed)


def update_file(relpath, old_version, new_version, userdir, old_perms, old_skel = None, dry_run=False):
    if not old_skel:
        old_skel = "/omd/versions/%s/skel" % old_version
    new_skel = "/omd/versions/%s/skel" % new_version

    replacements = {
        "###SITE###" : g_sitename,
        "###ROOT###" : g_sitedir,
    }
    for hook_name in g_site_conf:
        replacements["###CONFIG_%s###" % hook_name] = g_site_conf[hook_name]

    old_path = old_skel + "/" + relpath
    new_path = new_skel + "/" + relpath
    user_path = userdir + "/" + relpath

    old_type  = filetype(old_path)
    new_type  = filetype(new_path)
    user_type = filetype(user_path)

    # compare our new version with the user's version
    type_differs, content_differs, differs = file_status(user_path, new_path)

    # compare our old version with the user's version
    user_changed_type, user_changed_content, user_changed = file_status(old_path, user_path)

    # compare our old with our new version
    we_changed_type, we_changed_content, we_changed = file_status(old_path, new_path)

    non_empty_directory = not os.path.islink(user_path) and os.path.isdir(user_path) and bool(os.listdir(user_path))

#     if opt_verbose:
#         sys.stdout.write("%s%s%s:\n" % (tty_bold, relpath, tty_normal))
#         sys.stdout.write("  you       : %s\n" % user_type)
#         sys.stdout.write("  %-10s: %s\n" % (old_version, old_type))
#         sys.stdout.write("  %-10s: %s\n" % (new_version, new_type))

    # A --> MISSING FILES

    # Handle cases with missing files first. At least old or new are present,
    # or this function would never have been invoked.
    fn = tty_bold + relpath + tty_normal

    # 1) New version ships new skeleton file -> simply install
    if not old_type and not user_type:
        if not os.path.isdir(os.path.dirname(user_path)):
            # 1a) parent folder does not exist, skip installing new files for removed folders
            sys.stdout.write(good + " Unwanted       %s (new but deleted parent folder in local site)\n" % fn)
        else:
            # 1b) install new file
            create_skeleton_file(new_skel, userdir, relpath, replacements)
            sys.stdout.write(good + " Installed %-4s %s\n" % (new_type, fn))

    # 2) new version ships new skeleton file, but user's own file/dir/link
    #    is in the way.
    # 2a) the users file is identical with our new version
    elif not old_type and not differs:
        sys.stdout.write(good + " Identical new  %s\n" % fn)

    # 2b) user's file has a different content or type
    elif not old_type:
        if dry_run:
            print_conflict(relpath, "new file would overwrite existing file")
        else:
            if user_confirms("Conflict at " + relpath,
                        "The new version ships the %s %s, "
                        "but you have created a %s in that place "
                        "yourself. Shall we keep your %s or replace "
                        "is with my %s?" % (new_type, relpath, user_type, user_type, new_type),
                        relpath,
                        "keep", "Keep your %s" % user_type,
                        "replace", "Replace your %s with the new default %s" % (user_type, new_type)):
                sys.stdout.write(warn + " Keeping your   %s\n" % fn)
            else:
                create_skeleton_file(new_skel, userdir, relpath, replacements)
                sys.stdout.write(good + " Installed %-4s %s\n" % (new_type, fn))

    # 3) old version had a file which has vanished in new (got obsolete). If the user
    #    has deleted it himself, we are just happy
    elif not new_type and not user_type:
        sys.stdout.write(good + " Obsolete       %s\n" % fn)

    # 3b) same, but user has not deleted and changed type
    elif not new_type and user_changed_type:
        if dry_run:
            print_conflict(relpath, "local file type changed but file is going to be removed")
        else:
            if user_confirms("Obsolete file " + relpath,
                        "The %s %s has become obsolete in "
                        "this version, but you have changed it into a "
                        "%s. Do you want to keep your %s or "
                        "may I delete it for you, please?" % (old_type, relpath, user_type, user_type),
                        relpath,
                        "keep", "Keep your %s" % user_type,
                        "delete", "Delete it"):
                sys.stdout.write(warn + " Keeping your   %s\n" % fn)
            else:
                delete_user_file(user_path)
                sys.stdout.write(warn + " Deleted        %s\n" % fn)

    # 3c) same, but user has changed it contents
    elif not new_type and user_changed_content:
        if re.match('var/.*\.log$', relpath):
            # simply keep old logs which should have never been in skel/ in first place
            pass
        elif dry_run:
            print_conflict(relpath, "local file content changed but file is going to be removed")
        elif user_confirms("Changes in obsolete %s %s" % (old_type, relpath),
                "The %s %s has become obsolete in "
                "the new version, but you have changed its contents. "
                "Do you want to keep your %s or "
                "may I delete it for you, please?" % (old_type, relpath, user_type),
                relpath,
                "keep", "keep your %s, though it is obsolete" % user_type,
                "delete", "delete your %s" % user_type):
            sys.stdout.write(warn + " Keeping your   %s\n" % fn)
        else:
            delete_user_file(user_path)
            sys.stdout.write(warn + " Deleted        %s\n" % fn)

    # 3d) same, but it is a directory which is not empty
    elif not new_type and non_empty_directory:
        if "var/log/" in relpath:
            # do not complain about old logfiles
            pass
        elif dry_run:
            print_conflict(relpath, "directory still contains files but its is going to be removed")
        elif user_confirms("Non empty obsolete directory %s" % (relpath),
                "The directory %s has become obsolete in "
                "the new version, but you have contents in it. "
                "Do you want to keep your directory or "
                "may I delete it for you, please?" % (relpath),
                relpath,
                "keep", "keep your directory, though it is obsolete",
                "delete", "delete your directory"):
            sys.stdout.write(warn + " Keeping your   %s\n" % fn)
        else:
            delete_user_file(user_path)
            sys.stdout.write(warn + " Deleted        %s\n" % fn)

    # 3e) same, but user hasn't changed anything -> silently delete
    elif not new_type:
        if re.match('var/.*\.log$', relpath):
            # simply keep old logs which should have never been in skel/ in first place
            pass
        delete_user_file(user_path)
        sys.stdout.write(good + " Vanished       %s\n" % fn)

    # 4) old and new exist, but user file not. User has deleted that
    #    file. We simply do nothing in that case. The user surely has
    #    a good reason why he deleted the file.
    elif not user_type and not we_changed:
        sys.stdout.write(good + " Unwanted       %s (unchanged, deleted in local site)\n" % fn)

    # 4b) File changed in new version.
    elif not user_type:
        sys.stdout.write(good + " Unwanted       %s (changed but deleted in local site)\n" % fn)

    # B ---> UNCHANGED, EASY CASES

    # 5) New version didn't change anything -> no need to update
    elif not we_changed:
        pass

    # 6) User didn't change anything -> take over new version
    elif not user_changed:
        create_skeleton_file(new_skel, userdir, relpath, replacements)
        sys.stdout.write(good + " Updated        %s\n" % fn)

    # 7) User changed, but accidentally exactly as we did -> no action neccessary
    elif not differs:
        sys.stdout.write(good + " Identical      %s\n" % fn)

    # TEST UNTIL HERE

    # C ---> PATCH DAY, HANDLE FILES
    # 7) old, new and user are files. And all are different
    elif old_type == "file" and new_type == "file" and user_type == "file":
        try:
            merge_update_file(relpath, userdir, old_version, new_version, old_skel, dry_run=dry_run)
        except KeyboardInterrupt:
            raise
        except Exception as e:
            if dry_run:
                print_conflict(relpath, "merge exception")
                if opt_verbose:
                    print("%s\n", e)
            else:
                sys.stdout.write(error + " Exception      %s%s%s (cannot merge: %s)\n" % (tty_bold, relpath, tty_normal, e))

    # D ---> SYMLINKS
    # 8) all are symlinks, all changed
    elif old_type == "link" and new_type == "link" and user_type == "link":
        if dry_run:
            print_conflict(relpath, ("symlink target change conflict - previous: %s | current: %s | update: %s" % (os.readlink(old_path), os.readlink(user_path), os.readlink(new_path))))
        elif user_confirms("Symbolic link conflict at " + relpath,
                "'%s' is a symlink that pointed to "
                "%s in the old version and to "
                "%s in the new version. But meanwhile you "
                "changed to link target to %s. "
                "Shall I keep your link or replace it with "
                "the new default target?" %
                (relpath, os.readlink(old_path), os.readlink(new_path), os.readlink(user_path)),
                relpath,
                "keep", "Keep your symbolic link pointing to %s" % os.readlink(user_path),
                "replace", "Change link target to %s" % os.readlink(new_path)):
            sys.stdout.write(warn + " Keeping your   %s\n" % fn)
        else:
            os.remove(user_path)
            os.symlink(os.readlink(new_path), user_path)
            sys.stdout.write(warn + " Set link       %s to new target %s\n" % (fn, os.readlink(new_path)))

    # E ---> FILE TYPE HAS CHANGED (NASTY)

    # Now we have to handle cases, where the file types of the three
    # versions are not identical and at the same type the user or
    # have changed the third file to. We cannot merge here, the user
    # has to decide wether to keep his version of use ours.

    # 9) We have changed the file type
    elif old_type != new_type:
        if dry_run:
            print_conflict(relpath, ("file type changed - previous: %s | current: %s | update: %s" % (old_type, user_type, new_type)))
        else:
            if user_confirms("File type change at " + relpath,
                    "The %s %s has been changed into a %s in "
                    "the new version. Meanwhile you have changed "
                    "the %s of your copy of that %s. "
                    "Do you want to keep your version or replace "
                    "it with the new default? " %
                    (old_type, relpath, new_type, user_changed_type and "type" or "content",
                    old_type),
                    relpath,
                    "keep", "Keep your %s" % user_type,
                    "replace", "Replace it with the new %s" % new_type):
                sys.stdout.write(warn + " Keeping your version of %s\n" % fn)
            else:
                create_skeleton_file(new_skel, userdir, relpath, replacements)
                sys.stdout.write(warn + " Replaced your %s %s by new default %s.\n" % (user_type, relpath, new_type))

    # 10) The user has changed the file type, we just the content
    elif old_type != user_type:
        if dry_run:
            print_conflict(relpath, ("file type changed - previous: %s | current: %s | update: %s" % (old_type, user_type, new_type)))
        else:
            if user_confirms("Type change conflicts with content change at " + relpath,
                    "Usually %s is a %s in both the "
                    "old and new version. But you have changed it "
                    "into a %s. Do you want to keep that or may "
                    "I replace your %s with the new default "
                    "%s, please?" %
                    (relpath, old_type, user_type, user_type, new_type),
                    relpath,
                    "keep", "Keep your %s" % user_type,
                    "replace", "Replace it with the new %s" % new_type):
                sys.stdout.write(warn + " Keeping your %s %s.\n" % (user_type, fn))
            else:
                create_skeleton_file(new_skel, userdir, relpath, replacements)
                sys.stdout.write(warn + " Delete your %s and created new default %s %s.\n" %
                        (user_type, new_type, fn))

    # 11) This case should never happen, if I've not lost something
    else:
        if dry_run:
            print_conflict(relpath, "unexpected and unhandled update issue")
        else:
            if user_confirms("Something nasty happened at " + relpath,
                "You somehow fiddled along with "
                "%s, and I do not have the "
                "slightest idea what's going on here. May "
                "I please install the new default %s "
                "here, or do you want to keep your %s?" %
                (relpath, new_type, user_type),
                relpath,
                "keep", "Keep your %s" % user_type,
                "replace", "Replace it with the new %s" % new_type):
                sys.stdout.write(warn + " Keeping your %s %s.\n" % (user_type, fn))
            else:
                create_skeleton_file(new_skel, userdir, relpath, replacements)
                sys.stdout.write(warn + " Delete your %s and created new default %s %s.\n" % (user_type, new_type, fn))


    # Now the new file/link/dir is in place, deleted or whatever. The
    # user might have interferred and changed things. We need to make sure
    # that file permissions are also updated. But the user might have changed
    # something himself.

    user_type = filetype(user_path)
    old_perm     = get_skel_permissions(old_version, old_perms, relpath, old_skel)
    new_perm     = get_skel_permissions(new_version, g_skel_permissions, relpath)
    user_perm    = get_file_permissions(user_path)

    # Fix permissions not for links and only if the new type is as expected
    # and the current permissions are not as the should be
    what = None
    if new_type != "link" \
        and user_type == new_type \
        and user_perm != new_perm:

        # Permissions have changed, but file type not
        if old_type == new_type \
            and user_perm != old_perm \
            and old_perm != new_perm:
            if dry_run:
                print_conflict(relpath, ("permission conflict - previous: %04o | current: %04o | update: %04o" % (old_perm, user_perm, new_perm)))
            else:
                if user_confirms("Permission conflict at " + relpath,
                        "The proposed permissions of %s have changed from %04o "
                        "to %04o in the new version, but you have set %04o. "
                        "May I use the new default permissions or do "
                        "you want to keep yours?" %
                        (relpath, old_perm, new_perm, user_perm),
                        relpath,
                        "keep", "Keep permissions at %04o" % user_perm,
                        "default", "Set permission to %04o" % new_perm):
                    what = "keep"
                else:
                    what = "default"


        # Permissions have changed, no conflict with user
        elif old_type == new_type \
            and user_perm == old_perm:
                what = "default"

        # Permissions are not correct: all other cases (where type is as expected)
        elif old_perm != new_perm:
            if dry_run:
                print_conflict(relpath, ("permission conflict - previous: %04o | current: %04o | update: %04o" % (old_perm, user_perm, new_perm)))
            else:
                if user_confirms("Wrong permission of " + relpath,
                        "The proposed permissions of %s are %04o, but currently are "
                        "%04o. May I use the new default "
                        "permissions or keep yours?" % (relpath, new_perm, user_perm),
                        relpath,
                        "keep", "Keep permissions at %04o" % user_perm,
                        "default", "Set permission to %04o" % new_perm):
                    what = "keep"
                else:
                    what = "default"

        if what == "keep":
            sys.stdout.write(warn + " Permissions    %04o %s (unchanged)\n" % (user_perm, fn))
        elif what == "default":
            try:
                os.chmod(user_path, new_perm)
                sys.stdout.write(good + " Permissions    %04o -> %04o %s\n" % (user_perm, new_perm, fn))
            except Exception as e:
                sys.stdout.write(error + " Permission:    cannot change %04o -> %04o %s: %s\n" % (user_perm, new_perm, fn, e))

    if opt_verbose and dry_run:
        print_update_file_details(relpath, old_perms, old_path, old_version, old_skel, new_path, new_version)


def filetype(p):
    # check for symlinks first. Might be dangling. In that
    # case os.path.exists checks the links target for existance
    # and reports it is non-existing.
    if os.path.islink(p):
        tp = "link"
    elif not os.path.exists(p):
        tp = None
    elif os.path.isdir(p):
        tp = "dir"
    else:
        tp = "file"

    return tp


# Returns the file contents of a site file or a skel file
def file_contents(path):
    if '/skel/' in path:
        return instantiate_skel(path)
    else:
        return open(path, "rb").read()

def print_conflict(path, message):
    global g_conflicts
    g_conflicts += 1
    sys.stdout.write(error + " Conflict       %s%s%s (%s)\n" % (tty_bold, path, tty_normal, message))

def print_update_file_details(relpath, old_perms, old_path, old_version, old_skel, new_path, new_version):
    sys.stdout.write("\nUpdate details:\n\n")
    site_path    = os.path.join(g_sitedir, relpath)
    old_perm     = get_skel_permissions(old_version, old_perms, relpath, old_skel)
    new_perm     = get_skel_permissions(new_version, g_skel_permissions, relpath)
    user_perm    = get_file_permissions(site_path)

    def print_file_info(path, perm):
        file_type = filetype(path)
        sys.stdout.write("  - type:        %s\n" % file_type)
        if file_type == "file" or file_type == "dir":
            sys.stdout.write("  - permission:  %04o\n" % perm)
        if file_type == "link":
            sys.stdout.write("  - destination: %s\n" % os.readlink(path))
        sys.stdout.write("\n")

    sys.stdout.write("%s (previous version)\n" % old_path)
    print_file_info(old_path, old_perm)

    sys.stdout.write("%s (current site)\n" % relpath)
    print_file_info(site_path, user_perm)

    sys.stdout.write("%s (next version)\n" % new_path)
    print_file_info(new_path, new_perm)

    arrow = tty_magenta + '->' + tty_normal
    sys.stdout.write("\nPlanned content changes:\n")
    if old_perm != new_perm and user_perm != new_perm:
        sys.stdout.write("  - Permissions: %04o %s %04o\n" % (user_perm, arrow, new_perm))

    old_type = filetype(old_path)
    new_type = filetype(new_path)
    user_type = filetype(site_path)
    if old_type != new_type and user_type != new_type:
        sys.stdout.write("  - Type:        %s %s %s\n" % (user_type, arrow, new_type))

    if old_type == "file" and new_type == "file":
        old_content = file_contents(old_path)
        new_content = file_contents(new_path)
        if old_content != new_content:
            sys.stdout.write("  - Content update:\n")
            os.system("diff -u %s %s" % (old_path, new_path))

    if old_type == "link" and new_type == "link":
        old_link = os.readlink(old_path)
        new_link = os.readlink(new_path)
        if old_link != new_link:
            sys.stdout.write("  - Link target: %s %s %s\n" % (old_link, arrow, new_link))

    if old_type == "dir" and new_type == None:
        # print remaining files of folder
        sys.stdout.write("\nRemaining files:\n")
        for item in os.listdir(old_path):
            sys.stdout.write("  - %s\n" % (item))


#.
#   .--tmpfs---------------------------------------------------------------.
#   |                     _                    __                          |
#   |                    | |_ _ __ ___  _ __  / _|___                      |
#   |                    | __| '_ ` _ \| '_ \| |_/ __|                     |
#   |                    | |_| | | | | | |_) |  _\__ \                     |
#   |                     \__|_| |_| |_| .__/|_| |___/                     |
#   |                                  |_|                                 |
#   +----------------------------------------------------------------------+
#   |  Helper functions for dealing with the tmpfs                         |
#   '----------------------------------------------------------------------'

def tmpfs_mounted(sitename):
    # Problem here: if /omd is a symbolic link somewhere else,
    # then in /proc/mounts the physical path will appear and be
    # different from tmp_path. We resolve the path prior to comparing.
    tmp = tmp_dir(sitename)
    for line in open("/proc/mounts"):
        try:
            device, mp, fstype, options, dump, fsck = line.split()
            if mp == os.path.realpath(tmp) and fstype == 'tmpfs':
                return True
        except Exception:
            continue
    return False

def prepare_and_populate_tmpfs(sitename):
    tmp = tmp_dir(sitename)

    # Only try to mount the tmpfs if it is enabled for this site
    # When not using the tmpfs the tmp/ hierarchy needs to be
    # to be populated like the tmpfs afterwards.
    if g_site_conf["TMPFS"] == "on":
        if tmpfs_mounted(sitename):
            return False

        sys.stdout.write("Creating temporary filesystem %s..." % tmp)
        sys.stdout.flush()
        if not os.path.exists(tmp):
            os.mkdir(tmp)
        if 0 != os.system("mount %s '%s'" % (g_info["MOUNT_OPTIONS"], tmp) ):
            sys.stdout.write(tty_error + "\n")
            return False
    else:
        # Skip initializing when either the tmp dir does not exist
        # and the site is not totally stopped
        if os.path.exists(tmp) and not site_is_stopped(sitename):
            return False

        sys.stdout.write("Preparing tmp directory %s..." % tmp)
        sys.stdout.flush()
        if not os.path.exists(tmp):
            os.mkdir(tmp)

    create_skeleton_files(sitename, "tmp")
    chown_tree(tmp, sitename)
    ok()
    return True

def unmount_tmpfs(sitename, output = True, kill = False):
    # Clear directory hierarchy when not using a tmpfs
    # During omd update TMPFS hook might not be set so assume
    # that the hook is enabled by default.
    # If kill is True, then we do an fuser -k on the tmp
    # directory first.
    tmp = tmp_dir(sitename)
    if not tmpfs_mounted(sitename):
        if os.path.exists(tmp):
            if output:
                sys.stdout.write("Cleaning up temp filesystem...")
                sys.stdout.flush()
            delete_directory_contents(tmp)
            if output:
                ok()
        return True

    if output:
        sys.stdout.write("Unmounting temporary filesystem...")

    for t in range(0, 10):
        if 0 == os.system("umount '%s'" % tmp):
            if output:
                ok()
            delete_directory_contents(tmp)
            return True

        if kill:
            if output:
                sys.stdout.write("Killing processes still using '%s'\n" % tmp)
            os.system("fuser --silent -k '%s'" % tmp)

        if output:
            sys.stdout.write(kill and "K" or ".")
            sys.stdout.flush()
        time.sleep(1)

    if output:
        bail_out(tty_error + ": Cannot unmount tmp filesystem.")
    else:
        return False

def add_to_fstab(sitename, tmpfs_size = None):
    # tmpfs                   /opt/omd/sites/b01/tmp  tmpfs   user,uid=b01,gid=b01 0 0
    mountpoint = tmp_dir(sitename)

    # No size option: using up to 50% of the RAM
    sizespec = ''
    if tmpfs_size != None and re.match('^[0-9]+(G|M|%)$', tmpfs_size):
        sizespec = ',size=%s' % tmpfs_size

    entry = "tmpfs  %s tmpfs noauto,user,mode=755,uid=%s,gid=%s%s 0 0\n" % (mountpoint, sitename, sitename, sizespec)

    # skip adding if already there
    if os.path.exists("/etc/fstab"):
        for line in open("/etc/fstab"):
            if line.find(entry) != -1:
                return

    sys.stdout.write("Adding %s to /etc/fstab..." % mountpoint)

    open("/etc/fstab", "a+").write(entry)

    # avoid: (hint) your fstab has been modified, but systemd still uses
    # the old version; use 'systemctl daemon-reload' to reload.
    os.system("systemctl daemon-reload >/dev/null 2>&1")

    ok()

def remove_from_fstab(sitename):
    mountpoint = tmp_dir(sitename)
    sys.stdout.write("Removing %s from /etc/fstab..." % mountpoint)
    newtab = open("/etc/fstab.new", "w")
    for line in open("/etc/fstab"):
        if "uid=%s," % sitename in line and mountpoint in line:
            continue
        newtab.write(line)
    os.rename("/etc/fstab.new", "/etc/fstab")

    # avoid: (hint) your fstab has been modified, but systemd still uses
    # the old version; use 'systemctl daemon-reload' to reload.
    os.system("systemctl daemon-reload >/dev/null 2>&1")

    ok()


#.
#   .--init.d--------------------------------------------------------------.
#   |                        _       _ _        _                          |
#   |                       (_)_ __ (_) |_   __| |                         |
#   |                       | | '_ \| | __| / _` |                         |
#   |                       | | | | | | |_ | (_| |                         |
#   |                       |_|_| |_|_|\__(_)__,_|                         |
#   |                                                                      |
#   +----------------------------------------------------------------------+
#   |  Handling of site-internal init scripts                              |
#   '----------------------------------------------------------------------'

def init_scripts(sitename):
    rc_dir = "/omd/sites/%s/etc/rc.d" % sitename
    try:
        scripts = os.listdir(rc_dir)
        scripts.sort()
        return rc_dir, scripts
    except Exception:
        return rc_dir, []

def call_init_script(scriptpath, command):
    if not os.path.exists(scriptpath):
        sys.stderr.write('ERROR: This daemon does not exist.\n')
        return False
    try:
        return subprocess.call([scriptpath, command]) in [ 0, 5 ]
    except OSError as e:
        sys.stderr.write("ERROR: Failed to run '%s': %s\n" % (scriptpath, e))
        if e.errno == 13: # [Errno 13] Permission denied
            return False


def call_init_scripts(sitename, command, daemon = None):
    # Restart: Do not restart each service after another,
    # but first do stop all, then start all again! This
    # preserves the order.
    if command == "restart":
        call_init_scripts(sitename, "stop", daemon)
        call_init_scripts(sitename, "start", daemon)
        return

    # OMD guarantees OMD_ROOT to be the current directory
    os.chdir(site_dir(sitename))

    if daemon:
        ok = call_init_script("%s/etc/init.d/%s" % (g_sitedir, daemon), command)

    else:
        # Call stop scripts in reverse order. If daemon is set,
        # then only that start script will be affected
        rc_dir, scripts = init_scripts(sitename)
        if command == "stop":
            scripts.reverse()
        ok = True

        site_config = parse_site_conf(sitename)
        for script in scripts:
            rc_info = get_init_script_meta(os.path.join(rc_dir, script), site_config)
            if rc_info != None and rc_info["unused"]:
                continue
            if not call_init_script("%s/%s" % (rc_dir, script), command):
                ok = False

    if ok:
         return 0
    else:
         return 2

def check_status(sitename, display=True, daemon=None, bare=False):
    num_running = 0
    num_unused = 0
    num_stopped = 0
    uid = pwd.getpwnam(g_sitename).pw_uid
    processlist = []
    for process in psutil.process_iter():
        try:
            if process.uids().real != uid:
                continue
            processlist.append({'pid': process.pid, 'name': process.name(), 'cmdline': " ".join(process.cmdline())})
        except psutil.NoSuchProcess as e:
            # that's fine, probably short lived process or just exited
            continue

    site_config = parse_site_conf(sitename)
    rc_dir, scripts = init_scripts(sitename)
    components = [ s.split('-', 1)[-1] for s in scripts ]
    if daemon and daemon not in components:
        if not bare:
            sys.stderr.write('ERROR: This daemon does not exist.\n')
        return 3

    # get widest known enabled script
    rc_metas = {}
    output_size = 16
    for script in scripts:
        komponent = script.split("/")[-1].split('-', 1)[-1]
        if daemon and komponent != daemon:
            continue
        rc_info = get_init_script_meta(os.path.join(rc_dir, script), site_config, processlist=processlist)
        rc_metas[komponent] = rc_info
        if rc_info != None and rc_info["unused"] != None:
            if rc_info["unused"]:
                continue
        l = len(komponent)+2
        if l > output_size:
            output_size = l

    for script in scripts:
        komponent = script.split("/")[-1].split('-', 1)[-1]
        if daemon and komponent != daemon:
            continue

        # assume state from init script meta data config option and pidfile
        rc_info = rc_metas[komponent]
        state = None
        if rc_info != None and rc_info["unused"] != None:
            if rc_info["unused"]:
                state = 5
            elif rc_info["pidfile"]:
                if rc_info["pid"]:
                    state = 0
                else:
                    state = 1

        if state == None:
            # make sure init scripts are not accidentally run as root user
            bail_out_if_root("init hook '%s/%s' must not run as root user.\n" % (rc_dir, script))
            state = os.system("%s/%s status >/dev/null 2>&1" % (rc_dir, script)) >> 8

        if display and (state != 5 or opt_verbose):
            if bare:
                sys.stdout.write(komponent + " ")
            else:
                sys.stdout.write(("%-"+str(output_size)+"s") % (komponent + ":"))
                sys.stdout.write(tty_bold)

        if bare:
            if state != 5 or opt_verbose:
                sys.stdout.write("%d\n" % state)

        if state == 0:
            if display and not bare:
                sys.stdout.write(tty_green + "running\n")
            num_running += 1
        elif state == 5:
            if display and opt_verbose and not bare:
                sys.stdout.write(tty_blue + "unused\n")
            num_unused += 1
        else:
            if display and not bare:
                sys.stdout.write(tty_red + "stopped\n")
            num_stopped += 1
        if display and not bare:
            sys.stdout.write(tty_normal)

    if num_stopped > 0 and num_running == 0:
        exit_code = 1
        ovstate = tty_red + "stopped"
    elif num_running > 0 and num_stopped == 0:
        exit_code = 0
        ovstate = tty_green + "running"
    elif num_running == 0 and num_stopped == 0:
        exit_code = 1
        ovstate = tty_blue + "unused"
    else:
        exit_code = 2
        ovstate = tty_yellow + "partially running"
    if display:
        if bare:
            sys.stdout.write("OVERALL %d\n" % exit_code)
        else:
            sys.stdout.write(("-"*(output_size+7)) +"\n")
            sys.stdout.write(("%-"+str(output_size)+"s%s\n") % ("Overall state:", tty_bold + ovstate + tty_normal))
    return exit_code


def get_init_script_meta(script, site_config, processlist=None):
    meta = {
        "pidfile": None,
        "pid": None,
        "binary": None,
        "argmatch": None,
        "depends": [],
        "unused": None,
    }
    in_info_block = False
    with open(script) as file:
        for i in range(15):
            try:
                line = next(file).strip()
                if line.find("OMD INIT INFO") != -1:
                    in_info_block = True
                if line.find("END INIT INFO") != -1:
                    break
                if not in_info_block:
                    continue
                info = re.findall("^#\s*(\w+):\s(.*)$", line)
                if len(info) == 0:
                    continue
                match = info[0]
                if match[0] == "PIDFILE":
                    meta["pidfile"] = match[1].strip()
                elif match[0] == "BINARY":
                    meta["binary"] = match[1].strip()
                elif match[0] == "ARGMATCH":
                    meta["argmatch"] = match[1].strip()
                elif match[0] == "DEPENDS":
                    depends = re.findall("CONFIG_(\w+)\s*([\!=]+)\s*(.*?)\s*$", line)
                    if len(depends) == 1:
                        meta["depends"].append(depends[0])
                    else:
                        sys.stderr.write("syntax error in omd init info depends: %s in file %s\n" % (line, script))
                else:
                    sys.stderr.write("unsupported omd init info attribute: %s in file %s\n" % (line, script))
            except StopIteration as e:
                break


    if not in_info_block:
        return meta

    if len(meta["depends"]) > 0:
        meta["unused"] = False
        for (var, op, val) in meta["depends"]:
            conf_value = site_config.get(var, None)
            if conf_value == None:
                sys.stderr.write("unknown config variable: %s in file %s\n" % (var, script))
                continue

            if op == "=" or op == "==":
                if val != conf_value:
                    meta["unused"] = True
                    break
            elif op == "!=":
                if val == conf_value:
                    meta["unused"] = True
                    break
            else:
                sys.stderr.write("unknown operator: %s in file %s\n" % (op, script))

    if meta["pidfile"] != None:
        try:
            with open(meta["pidfile"], 'r') as fd:
                pid = fd.read().strip()
                if check_pid(pid):
                    meta["pid"] = pid
                else:
                    # remove stale pid file
                    sys.stderr.write("removing stale pid file: %s\n" % meta["pidfile"])
                    os.remove(meta["pidfile"])
        except Exception:
            pass

    if meta["pid"] == None and meta["binary"] != None and processlist != None:
        for p in processlist:
            if p['cmdline'].find(meta["binary"]) != -1 and p['cmdline'].find(meta["argmatch"]) != -1:
                meta["pid"] = p['pid']
                break

    if meta["pid"] != None:
        meta["unused"] = False

    return meta


def check_pid(pid):
    try:
        os.kill(pid, 0)
    except OSError:
        return False
    else:
        return True

#.
#   .--Config & Hooks------------------------------------------------------.
#   |  ____             __ _          ___     _   _             _          |
#   | / ___|___  _ __  / _(_) __ _   ( _ )   | | | | ___   ___ | | _____   |
#   || |   / _ \| '_ \| |_| |/ _` |  / _ \/\ | |_| |/ _ \ / _ \| |/ / __|  |
#   || |__| (_) | | | |  _| | (_| | | (_>  < |  _  | (_) | (_) |   <\__ \  |
#   | \____\___/|_| |_|_| |_|\__, |  \___/\/ |_| |_|\___/ \___/|_|\_\___/  |
#   |                        |___/                                         |
#   +----------------------------------------------------------------------+
#   |  Site configuration and config hooks                                 |
#   '----------------------------------------------------------------------'

# Hooks are scripts in lib/omd/hooks that are being called with one
# of the following arguments:
#
# default - return the default value of the hook. Mandatory
# set     - implements a new setting for the hook
# choices - available choices for enumeration hooks
# depends - exists with 1, if this hook misses its dependent hook settings

# Parse the file site.conf of a site into a dictionary. Does
# not use any global variables. Has no side effects.
def parse_site_conf(sitename):
    config = {}
    confpath = "/omd/sites/%s/etc/omd/site.conf" % sitename
    if not os.path.exists(confpath):
        return {}

    for line in open(confpath):
        line = line.strip()
        if line == "" or line[0] == "#":
            continue
        var, value = line.split("=", 1)
        if not var.startswith("CONFIG_"):
            sys.stderr.write("Ignoring invalid variable %s.\n" % var)
        else:
            config[var[7:].strip()] = value.strip().strip("'")

    return config



# Load all variables from omd/sites.conf. These variables always begin with
# CONFIG_. The reason is that this file can be sources with the shell. Puts
# these variables into the global dict g_site_conf without the CONFIG_. Also
# puts the variables into the environment.
def load_site_conf(skipMissing = False):
    global g_site_conf
    g_site_conf = parse_site_conf(g_sitename)

    if skipMissing:
        return

    # Get the default values of all config hooks that are not contained
    # in the site configuration. This can happen if there are new hooks
    # after an update or when a site is being created.
    missing = False
    hook_dir = omd_root() + "/lib/omd/hooks"
    if os.path.exists(hook_dir):
        for hook_name in os.listdir(hook_dir):
            if hook_name[0] != '.' and hook_name not in g_site_conf:
                missing = True
                if not am_root():
                    content = call_hook(hook_name, ["default"])[1]
                    g_site_conf[hook_name] = content

    if missing:
        if am_root():
            call_as_forked_site_user(load_site_conf, [], {"skipMissing":skipMissing})
            g_site_conf = parse_site_conf(g_sitename)
        else:
            save_site_conf()


# Put all site configuration (explicit and defaults) into environment
# variables beginning with CONFIG_
def create_config_environment():
    for varname, value in list(g_site_conf.items()):
        putenv("CONFIG_" + varname, value)


def save_site_conf():
    confdir = g_sitedir + "/etc/omd"

    if not os.path.exists(confdir):
        os.mkdir(confdir)

    f = open(g_sitedir + "/etc/omd/site.conf", "w")

    for hook_name, value in sorted(list(g_site_conf.items()), key=lambda x: x[0]):
        f.write("CONFIG_%s='%s'\n" % (hook_name, value))


# Get information about all hooks. Just needed for
# the "omd config" command.
def load_config_hooks():
    global g_config_hooks
    g_config_hooks = {}

    hook_dir = g_sitedir + "/lib/omd/hooks"
    for hook_name in os.listdir(hook_dir):
        try:
            if hook_name[0] != '.':
                hook = config_load_hook(hook_name)
                # only load configuration hooks
                if hook.get("menu", None) != None:
                    g_config_hooks[hook_name] = hook
        except Exception:
            pass
    create_config_environment()

def config_load_hook(hook_name):
    hook = { "name" : hook_name }

    description = ""
    description_active = False
    for line in open(g_sitedir + "/lib/omd/hooks/" + hook_name):
        if line.startswith("# Alias:"):
            hook["alias"] = line[8:].strip()
        elif line.startswith("# Menu:"):
            hook["menu"] = line[7:].strip()
        elif line.startswith("# Description:"):
            description_active = True
        elif line.startswith("#  ") and description_active:
            description += line[3:].strip() + "\n"
        else:
            description_active = False
    hook["description"] = description
    return hook

def load_hook_choices(hook):
    # The choices can either be a list of possible keys. Then
    # the hook outputs one live for each choice where the key and a
    # description are separated by a colon. Or it outputs one line
    # where that line is an extended regular expression matching the
    # possible values.
    choicestxt = call_hook(hook["name"], ["choices"])[1].split("\n")
    if len(choicestxt) == 1:
        regextext = choicestxt[0].strip()
        if regextext != "":
            choices = re.compile(regextext + "$")
        else:
            choices = None
    else:
        choices = []
        try:
            for line in choicestxt:
                val, descr = line.split(":", 1)
                val = val.strip()
                descr = descr.strip()
                choices.append( (val, descr) )
        except Exception:
            bail_out(tty_error + ": Invalid output of hook: %s" % choicestxt)

    hook["choices"] = choices
    return

def load_hook_dependencies():
    for hook_name, hook in list(g_config_hooks.items()):
        exitcode, content = call_hook(hook_name, ["depends"])
        if exitcode:
            hook["active"] = False
        else:
            hook["active"] = True


def hook_exists(hook_name):
    hook_file = g_sitedir + "/lib/omd/hooks/" + hook_name
    return os.path.exists(hook_file)


def call_hook(hook_name, args):
    hook_file = omd_root() + "/lib/omd/hooks/" + hook_name

    # make sure scripts are not accidentally run as root user
    bail_out_if_root("hook '%s %s' must not run as root user.\n" % (hook_file, " ".join(args)))

    putenv("OMD_ROOT", g_sitedir)
    putenv("OMD_SITE", g_sitename)
    p = subprocess.run([hook_file]+args, stdout=subprocess.PIPE, shell=False)
    content = p.stdout.decode("UTF-8").strip()
    exitcode = p.returncode
    if exitcode and args[0] != "depends":
        sys.stderr.write("Error running config hook (rc: %d): '%s %s %s': %s\n" % (exitcode, hook_file, command, " ".join(args), content))
    return exitcode, content


def config_change():
    # Check whether or not site needs to be stopped. Stop and remember to start again later
    site_was_stopped = False
    if not site_is_stopped(g_sitename):
        site_was_stopped = True
        stop_site(g_sitename)

    try:
        settings = read_config_change_commands()

        if not settings:
            bail_out(tty_error + ": You need to provide config change commands via stdin: KEY=value\n")

        validate_config_change_commands(settings)

        for key, value in settings:
            config_set_value(key, value, save=False)

        save_site_conf()
        config_set_all()
    finally:
        if site_was_stopped:
            start_site(g_sitename)


def read_config_change_commands():
    settings = []
    for l in sys.stdin:
        line = l.strip()
        if not line:
            continue

        try:
            key, value = line.split("=", 1)
            settings.append((key, value))
        except ValueError as e:
            bail_out(tty_error + ": Invalid config change command: %r" % line)
    return settings


def validate_config_change_commands(settings):
    # Validate the provided commands
    for key, value in settings:
        hook = g_config_hooks.get(key)
        if not hook:
            bail_out(tty_error + ": Invalid config option: %r" % key)

        # Check if value is valid. Choices are either a list of allowed
        # keys or a regular expression
        load_hook_choices(hook)
        if type(hook["choices"]) == list:
            choices = [ var for (var, descr) in hook["choices"] ]
            if value not in choices:
                bail_out(tty_error + ": Invalid value %r for %r. Allowed are: %s\n" % \
                        (value, key, ", ".join(choices)))
        else:
            if not hook["choices"].match(value):
                bail_out(tty_error + ": Invalid value %r for %r. Does not match allowed pattern.\n" %
                           (value, key))


def config_set(args):
    if len(args) != 2:
        sys.stderr.write("Please specify variable name and value\n")
        config_usage()
        sys.exit(1)

    if not site_is_stopped(g_sitename):
        if opt_force:
            sys.stdout.write("Warning: site should be stopped for configuration changes.\n")
        else:
            sys.stderr.write("Cannot change config variables while site is running.\n")
            sys.exit(1)

    hook_name = args[0]
    value = args[1]
    hook = g_config_hooks.get(hook_name)
    if not hook:
        sys.stderr.write("No such variable '%s'\n" % hook_name)
        sys.exit(1)

    # Check if value is valid. Choices are either a list of allowed
    # keys or a regular expression
    load_hook_choices(hook)
    if type(hook["choices"]) == list:
        choices = [ var for (var, descr) in hook["choices"] ]
        if value not in choices:
            sys.stderr.write("Invalid value for '%s'. Allowed are: %s\n" % \
                    (value, ", ".join(choices)))
            sys.exit(1)
    else:
        if not hook["choices"].match(value):
            sys.stderr.write("Invalid value for '%s'. Does not match allowed pattern.\n" % value)
            sys.exit(1)

    config_set_value(hook_name, value)


def config_set_all():
    if am_root():
        call_as_forked_site_user(config_set_all,[],{})
        return

    for hook_name, value in sorted(list(g_site_conf.items()), key=lambda x: x[0]):
        # Hooks might vanish after and up- or downgrade
        if hook_exists(hook_name):
            exitcode, output = call_hook(hook_name, [ "set", value ])
            if exitcode == 0 and output and output != value:
                g_site_conf[hook_name] = output
                putenv("CONFIG_" + hook_name, output)
                save_site_conf()



def config_set_value(hook_name, value, save = True):
    if os.getuid() == 0:
        sys.stderr.write("I am root. This should never happen!\n")
        sys.exit(1)

    # Call hook with 'set'. If it outputs something, that will
    # be our new value (i.e. hook disagrees with the new setting!)
    exitcode, answer = call_hook(hook_name, ["set", value])
    if exitcode:
        return

    if len(answer) > 0:
        value = answer.strip()

    g_site_conf[hook_name] = value
    putenv("CONFIG_" + hook_name, value)

    if save:
        save_site_conf()
        config_set_all()

def config_usage():
    sys.stdout.write("""Usage of config command:

omd config               - interactive configuration menu
omd config show          - show current settings of all configuration variables
omd config show VAR      - show current setting of variable VAR
omd config set VAR VALUE - set VAR to VALUE
omd config change        - change multiple at once. Provide newline separated
                           KEY=value pairs via stdin. The site is restarted
                           automatically once in case it's currently runnig.
""")

def config_show(args):
    load_hook_dependencies()
    if len(args) == 0:
        hook_names = list(g_config_hooks.keys())
        hook_names.sort()
        for hook_name in hook_names:
            hook = g_config_hooks[hook_name]
            if hook["active"]:
                sys.stdout.write("%s: %s\n" % (hook_name, g_site_conf[hook_name]))
    else:
        output = []
        for hook_name in args:
            hook = g_config_hooks.get(hook_name)
            if not hook:
                sys.stderr.write("No such variable %s\n" % hook_name)
                sys.exit(1)
            else:
                output.append(g_site_conf[hook_name])

        sys.stdout.write(" ".join(output))
        sys.stdout.write("\n")

def config_configure():
    load_hook_dependencies()
    hook_names = list(g_config_hooks.keys())
    hook_names.sort()
    current_hook_name = ""
    menu_open = False
    current_menu = "Basic"

    # force certain order in main menu
    menu_choices = [ "Basic", "Web GUI", "Addons", "Distributed Monitoring" ]

    while True:
        # Rebuild hook information (values possible changed)
        menu = {}
        for hook_name in hook_names:
            hook = g_config_hooks[hook_name]
            if hook["active"]:
                mp = hook.get("menu", "Other")
                entries = menu.get(mp, [])
                entries.append((hook_name, g_site_conf[hook_name]))
                menu[mp] = entries
                if mp not in menu_choices:
                    menu_choices.append(mp)

        # Handle main menu
        if not menu_open:
            change, current_menu = \
                dialog_menu("Configuration of site %s" % g_sitename,
                        "Interactive setting of site configuration variables. You "
                        "can change values only while the site is stopped.",
                        [ (e, "") for e in menu_choices ],
                        current_menu,
                        "Enter",
                        "Exit")
            if not change:
                return
            current_hook_name = None
            menu_open = True

        else:
            change, current_hook_name = \
                dialog_menu(
                    current_menu,
                    "",
                    menu[current_menu],
                    current_hook_name,
                    "Change",
                    "Main menu")
            if change:
                try:
                    config_configure_hook(current_hook_name)
                except Exception as e:
                    bail_out(tty_error + ": Error in hook %s: %s" % (current_hook_name, e))
            else:
                menu_open = False


def config_configure_hook(hook_name):
    if not site_is_stopped(g_sitename):
        if not dialog_yesno("You cannot change configuration value while the "
                "site is running. Do you want me to stop the site now?"):
            return
        stop_site(g_sitename)
        dialog_message("The site has been stopped.")

    hook = g_config_hooks[hook_name]
    title = hook["alias"]
    descr = hook["description"].replace("\n\n", "\001").replace("\n", " ").replace("\001", "\n\n")
    value = g_site_conf[hook_name]
    load_hook_choices(hook)
    choices = hook["choices"]
    if type(choices) == list:
        dialog_function = dialog_menu
    else:
        dialog_function = dialog_regex
    change, new_value = \
        dialog_function(title, descr, choices, value, "Change", "Cancel")
    if change:
        config_set_value(hook["name"], new_value)
        g_site_conf[hook_name] = new_value
        save_site_conf()
        config_set_all()
        load_hook_dependencies()

def call_init_hook(command, when):
    hook = "etc/init-hooks.d/omd-%s-%s" % (command, when)
    if not os.path.exists(hook):
        return

    # make sure init scripts are not accidentally run as root user
    bail_out_if_root("init hook '%s' must not run as root user.\n" % (hook))

    try:
        subprocess.check_call(hook)
    except PermissionError as e:
        sys.stderr.write(str(e)+"\n")
    except subprocess.CalledProcessError as e:
        bail_out(tty_error + ": %s: %s" % (g_sitename, e))

def init_action(command, args, options):
    if site_is_disabled(g_sitename):
        bail_out(tty_error + ": This site is disabled.")
    if site_needs_update(g_sitename):
        bail_out(tty_error + ": This site needs to be updated with: omd update")

    # restart is special, if there is a failing start-pre
    # hook but not a failing restart-pre hook `omd restart' can
    # start a stopped site
    call_init_hook(command, "pre")

    if command in [ "start", "restart", "check" ]:
        prepare_and_populate_tmpfs(g_sitename)

    if len(args) > 0:
        daemon = args[0] # restrict to this daemon
    else:
        daemon = None

    # OMD guarantees that we are in OMD_ROOT
    os.chdir(g_sitedir)

    if command == "status":
        return check_status(g_sitename, True, daemon, options.bare)
    else:
        return call_init_scripts(g_sitename, command, daemon)


#.
#   .--Helpers-------------------------------------------------------------.
#   |                  _   _      _                                        |
#   |                 | | | | ___| |_ __   ___ _ __ ___                    |
#   |                 | |_| |/ _ \ | '_ \ / _ \ '__/ __|                   |
#   |                 |  _  |  __/ | |_) |  __/ |  \__ \                   |
#   |                 |_| |_|\___|_| .__/ \___|_|  |___/                   |
#   |                              |_|                                     |
#   +----------------------------------------------------------------------+
#   |  Various helper functions                                            |
#   '----------------------------------------------------------------------'

def omd_root():
    return "/omd/versions/%s" % OMD_VERSION

# Read distro- and version specific values
def read_info():
    global g_info
    g_info = {}
    info_dir = omd_root() + "/share/omd"
    for f in os.listdir(info_dir):
        if f.endswith(".info"):
            for line in open(info_dir + "/" + f):
                try:
                    line = line.strip()
                    # Skip comment and empty lines
                    if line.startswith('#') or line == '':
                        continue
                    # Remove everything after the first comment sign
                    if '#' in line:
                        line = line[:line.index('#')].strip()
                    var, value = line.split('=')
                    value = value.strip()
                    if var.endswith("+"):
                        var = var[:-1] # remove +
                        g_info[var.strip()] += " " + value
                    else:
                        g_info[var.strip()] = value
                except Exception as e:
                    bail_out(tty_error + ': Unable to parse line "%s" in file "%s"' % (line, info_dir + "/" + f))

def fstab_verify(name):
    mountpoint = tmp_dir(name)
    for line in open("/etc/fstab"):
        if "uid=%s," % name in line and mountpoint in line:
            return True
    bail_out(tty_error + ": fstab entry for %s does not exist" % mountpoint )



# No using os.putenv, os.getenv os.unsetenv directly because
# they seem not to work correctly in debian 503.
#
# Unsetting all vars with os.unsetenv and after that using os.getenv to read
# some vars did not bring the expected result that the environment was empty.
# The vars were still set.
#
# Same for os.putenv. Executing os.getenv right after os.putenv did not bring
# the expected result.
#
# Directly modifying os.environ seems to work.
def putenv(key, value):
    os.environ[key] = value

def getenv(key, default = None):
    if not key in os.environ:
        return default
    return os.environ[key]

def clear_environment():
    # first remove *all* current environment variables
    keep = [ "TERM" ]
    for key in list(os.environ.keys()):
        if key not in keep:
            del os.environ[key]

def set_environment():
    putenv("OMD_SITE", g_sitename)
    putenv("OMD_ROOT", g_sitedir)
    putenv("PATH", "%s/local/bin:%s/bin:/usr/local/bin:/bin:/usr/bin:/sbin:/usr/sbin" %
                                                                  (g_sitedir, g_sitedir))
    putenv("USER", g_sitename)

    putenv("LD_LIBRARY_PATH", "%s/local/lib:%s/lib" % (g_sitedir, g_sitedir))
    putenv("HOME", g_sitedir)
    putenv("PYTHONPATH", "%s/lib/python:%s/local/lib/python" % (g_sitedir, g_sitedir))

    # allow user to define further environment variable in ~/etc/environment
    envfile = g_sitedir + "/etc/environment"
    if os.path.exists(envfile):
        lineno = 0
        for line in open(envfile):
            lineno += 1
            line = line.strip()
            if line == "" or line[0] == "#":
                continue # allow empty lines and comments
            parts = line.split("=")
            if len(parts) != 2:
                bail_out(tty_error + ": %s: syntax error in line %d" % (envfile, lineno))
            varname = parts[0]
            value = parts[1]
            if value.startswith('"'):
                value = value.strip('"')

            # Add the present environment when someone wants to append some
            if value.startswith("$%s:" % varname):
                before = getenv(varname, None)
                if before:
                    value = before + ":" + value.replace("$%s:" % varname, '')

            if value.startswith("'"):
                value = value.strip("'")
            putenv(varname, value)

    create_config_environment()

def hostname():
    try:
        return os.popen("hostname").read().strip()
    except Exception:
        return "localhost"

def create_apache_hook(sitename):
    open("/omd/apache/%s.conf" % sitename, "w")\
        .write("Include %s/etc/apache/mode.conf\n" % site_dir(sitename))
    open("/omd/apache/%s.include" % sitename, "w")\
        .write("Include %s/etc/apache/system.d/*.conf\n" % site_dir(sitename))
    sync_apache_maint_page(sitename)

def sync_apache_maint_page(sitename):
    maint_file  = '%s/var/www/maint.html' % site_dir(sitename)
    target_file = '/omd/apache/maint_%s.html' % sitename
    am_root = os.getuid() == 0
    if not am_root and not os.path.exists(target_file):
        return
    if os.path.exists(maint_file):
        os.system("rsync -a --inplace --chmod='F0644' --chown='%s:%s' '%s' '%s'" % (sitename, sitename, maint_file, target_file))

def delete_apache_hook(sitename):
    hook_path = "/omd/apache/%s.conf" % sitename
    if os.path.exists(hook_path):
        try:
            os.remove(hook_path)
        except Exception as e:
            sys.stderr.write("Cannot remove apache hook %s: %s\n" % (hook_path, e))

    hook_path = "/omd/apache/%s.include" % sitename
    if os.path.exists(hook_path):
        try:
            os.remove(hook_path)
        except Exception as e:
            sys.stderr.write("Cannot remove apache hook %s: %s\n" % (hook_path, e))

    hook_path = "/omd/apache/maint_%s.html" % sitename
    if os.path.exists(hook_path):
        try:
            os.remove(hook_path)
        except Exception as e:
            sys.stderr.write("Cannot remove apache hook %s: %s\n" % (hook_path, e))


def init_cmd(name, action):
    return g_info['INIT_CMD'] % {
        'name'   : name,
        'action' : action,
    }

def reload_apache():
    sys.stdout.write("Reloading Apache...")
    sys.stdout.flush()
    show_success(os.system("%s graceful" % g_info["APACHE_CTL"]) >> 8)

def restart_apache():
    if os.system(init_cmd(g_info['APACHE_INIT_NAME'], 'status') + ' >/dev/null 2>&1') >> 8 == 0:
        sys.stdout.write("Restarting Apache...")
        sys.stdout.flush()
        show_success(os.system(init_cmd(g_info['APACHE_INIT_NAME'], 'restart') + ' >/dev/null') >> 8)

def replace_tags(content, replacements):
    for var, value in list(replacements.items()):
        content = content.replace(var.encode("utf-8"), value.encode("utf-8"))
    return content

def get_editor():
    editor = getenv("VISUAL", getenv("EDITOR", "/usr/bin/vi"))
    if not os.path.exists(editor):
        editor = 'vi'
    return editor

# return "| $PAGER", if a pager is available
def pipe_pager():
    pager = getenv("PAGER")
    if not pager and os.path.exists("/usr/bin/less"):
        pager = "less -F -X"
    if pager:
        return "| %s" % pager
    else:
        return ""

def call_scripts(phase, prefix=None, args=None):
    if prefix is None:
        prefix = omd_root()
    path = "%s/lib/omd/scripts/%s" % (prefix, phase)
    exited_ok = True
    if not os.path.exists(path):
        return exited_ok

    if not phase.endswith("-root"):
        if am_root():
            return call_as_forked_site_user(call_scripts, [phase], {"prefix":prefix, "args":args})

    if not args:
        args = []
    putenv("OMD_ROOT", g_sitedir)
    putenv("OMD_SITE", g_sitename)
    for f in os.listdir(path):
        if f[0] == '.':
            continue
        sys.stdout.write('Executing %s script "%s"...' % (phase, f))
        sys.stdout.flush()
        p = subprocess.Popen(['%s/%s' % (path, f)]+args)
        exitcode = p.wait()
        if exitcode == 0:
            sys.stdout.write(tty_ok + '\n')
        elif exitcode == 5:
            sys.stdout.write(tty_yellow + 'skipped' + tty_normal + '\n')
        else:
            exited_ok = False
            sys.stdout.write(tty_error + ' (exit code: %d, use -v for details)\n' % exitcode)
    return exited_ok


def check_site_user(site_must_exist):
    if g_sitename != None and site_must_exist and not site_exists(g_sitename):
        if os.getuid() == 0:
            bail_out(tty_error + ": omd: no such site: %s" % g_sitename)
        else:
            bail_out(tty_error + ": omd: You need to execute omd as root or site user. %s is not a omd site." % g_sitename)


#.
#   .--Commands------------------------------------------------------------.
#   |         ____                                          _              |
#   |        / ___|___  _ __ ___  _ __ ___   __ _ _ __   __| |___          |
#   |       | |   / _ \| '_ ` _ \| '_ ` _ \ / _` | '_ \ / _` / __|         |
#   |       | |__| (_) | | | | | | | | | | | (_| | | | | (_| \__ \         |
#   |        \____\___/|_| |_| |_|_| |_| |_|\__,_|_| |_|\__,_|___/         |
#   |                                                                      |
#   +----------------------------------------------------------------------+
#   |  Implementation of actual omd commands                               |
#   '----------------------------------------------------------------------'

def main_help(args=[], options={}):
    am_root = os.getuid() == 0
    if am_root:
        sys.stdout.write("Usage (called as root):\n\n")
    else:
        sys.stdout.write("Usage (called as site user):\n\n")

    for cmd_spec in commands:
        synopsis = cmd_spec.args
        if cmd_spec.only_root and not am_root:
            continue
        if am_root:
            if cmd_spec.needs_site == 2:
                synopsis = "[SITE] " + synopsis
            elif cmd_spec.needs_site == 1:
                synopsis = "SITE " + synopsis

        synopsis_width = am_root and '23' or '16'
        sys.stdout.write((" omd %-10s %-"+synopsis_width+"s %s\n") % (cmd_spec.command, synopsis, cmd_spec.description))
    print_general_options()
    sys.stdout.write(" omd COMMAND -h, --help          show available options of COMMAND\n")

def print_general_options():
    sys.stdout.write("\nGeneral Options:\n"
                     " -V,--version=<version>          set specific version, useful in combination with update/create\n"
                     " -f,--force                      set global force flag used in several commands\n"
                     " -v,--verbose                    enable verbose output\n"
                     " -i,--interactive                enable interactive mode\n"
                    )

def main_setversion(args, options={}):
    if len(args) == 0:
        versions = [ (v, "Version %s" % v) for v in omd_versions() if not v == default_version() ]

        if use_update_alternatives():
            versions = [ ('auto', 'Auto (Update-Alternatives)') ] + versions

        ok, version = dialog_menu("Choose new default",
                "Please choose the version to make the new default",
                versions,
                None,
                "Make default",
                "Cancel")
        if not ok:
            bail_out("Aborted.")
    else:
        version = opt_version or args[0]

    if version != 'auto' and not version_exists(version):
        bail_out(tty_error + ": The given version does not exist.")
    if version == default_version():
        bail_out(tty_error + ": The given version is already default.")

    # Special handling for debian based distros which use update-alternatives
    # to control the path to the omd binary, manpage and so on
    if use_update_alternatives():
        if version == 'auto':
            os.system("update-alternatives --auto omd")
        else:
            os.system("update-alternatives --set omd /omd/versions/%s" % version)
    else:
        if os.path.islink("/omd/versions/default"):
            os.remove("/omd/versions/default")
        os.symlink("/omd/versions/%s" % version, "/omd/versions/default")


def use_update_alternatives():
    return os.path.exists("/var/lib/dpkg/alternatives/omd")


def main_version(args, options={}):
    if len(args) > 0:
        site = args[0]
        if not site_exists(site):
            bail_out(tty_error + ": No such site: %s" % site)
        version = site_version(site)
    else:
        version = g_info["OMD_VERSION"]
    if options.bare:
        sys.stdout.write(version + "\n")
    else:
        try:
            version += (", Addons: " + ", ".join(os.listdir("/omd/versions/%s/addon/" % version)))
        except Exception:
            pass
        version += (", Python version " + ".".join(str(x) for x in sys.version_info[:3]))
        sys.stdout.write("OMD - Open Monitoring Distribution Version %s\n" % version)


def main_versions(args, options={}):
    for v in omd_versions():
        addons=""
        try:
            addons = (", addons: " + ", ".join(os.listdir("/omd/versions/%s/addon/" % v)))
        except Exception:
            pass
        if v == default_version() and not options.bare:
            sys.stdout.write("%s (default%s)\n" % (v, addons))
        else:
            sys.stdout.write("%s%s\n" % (v,addons))

def default_version():
    return os.path.basename(os.path.realpath("/omd/versions/default"))

def omd_versions():
    try:
        return sorted([ v for v in os.listdir("/omd/versions") if v != "default" ])
    except OSError as e:
        if e.errno == 2:
            return []
        else:
            raise

def version_exists(v):
    return v in omd_versions()

def main_sites(args, options={}):
    if on_tty and not options.bare:
        sys.stdout.write("SITE             VERSION          COMMENTS\n")
    for site in all_sites():
        tags = []
        if options.bare:
            sys.stdout.write("%s\n" % site)
        else:
            disabled = site_is_disabled(site)
            needs_update = site_needs_update(site)
            v = site_version(site)
            if v is None:
                v = "(none)"
                tags.append("empty site dir")
            elif v == default_version():
                tags.append("default version")
            if disabled:
                tags.append(tty_bold + tty_red + "disabled" + tty_normal)
            if needs_update:
                tags.append(tty_bold + tty_red + "uninstalled" + tty_normal)
            try:
                tags.append("addons: " + ", ".join(os.listdir("/omd/versions/%s/addon/" % v)))
            except Exception:
                pass
            sys.stdout.write("%-16s %-16s %s " % (site, v, ", ".join(tags)))
            sys.stdout.write("\n")

# Bail out if name for new site is not valid (needed by create/mv/cp)
def sitename_must_be_valid(name, reuse = False):
    # Make sanity checks before starting any action
    if not reuse and site_exists(name):
        bail_out(tty_error + ": Site '%s' already existing." % name)
    if not reuse and group_exists(name):
        bail_out(tty_error + ": Group '%s' already existing." % name)
    if not reuse and user_exists(name):
        bail_out(tty_error + ": User '%s' already existing." % name)
    if not re.match("^[a-zA-Z_][a-zA-Z_0-9]{0,15}$", name):
        bail_out(tty_error + ": Invalid site name. Must begin with a character, may contain characters, digits and _ and have length 1 up to 16")


def main_create(args, options={}):
    reuse = False
    if options.reuse:
        reuse = True
        if not user_verify(g_sitename):
            bail_out(tty_error + ": Error verifying site user.")

    sitename_must_be_valid(g_sitename, reuse)

    sitedir = site_dir(g_sitename)
    version_base_path = os.path.realpath("%s/../../versions" % sitedir)
    if not os.path.exists(version_base_path):
        bail_out(tty_error + ": Error verifying versions folder: %s" % version_base_path)

    real_version_path = os.path.join(version_base_path, OMD_VERSION)
    if not call_scripts('pre-create-root', prefix=real_version_path, args=[g_sitename, OMD_VERSION]):
        sys.stdout.write("create canceled by pre-create script\n\n")
        sys.exit(1)

    # Create operating system user for site
    uid = options.uid
    gid = options.gid
    if not reuse:
        useradd(g_sitename, uid, gid)

    if reuse:
        fstab_verify(g_sitename)
    else:
        create_site_dir(g_sitename)
        add_to_fstab(g_sitename, tmpfs_size = options.tmpfs_size)

    config_settings = {}
    if options.no_autostart:
        config_settings["AUTOSTART"] = "off"
        sys.stdout.write("Going to set AUTOSTART to off.\n")

    if options.no_tmpfs:
        config_settings["TMPFS"] = "off"
        sys.stdout.write("Going to set TMPFS to off.\n")

    if not options.no_init:
        admin_password = init_site(config_settings, options)
        welcome_message(admin_password)

    else:
        sys.stdout.write("Create new site %s in disabled state and with empty %s.\n" % (g_sitename, sitedir))
        sys.stdout.write("You can now mount a filesystem to %s.\n" % (sitedir))
        sys.stdout.write("Afterwards you can initialize the site with 'omd init'.\n")

    os.chdir(sitedir)
    call_scripts('post-create-root', args=[g_sitename, OMD_VERSION])

def welcome_message(admin_password):
    sys.stdout.write("Created new site %s%s%s with version %s%s%s.\n\n" % (tty_bold, g_sitename, tty_normal, tty_bold, OMD_VERSION, tty_normal))
    sys.stdout.write("  The site can be started with '%somd start %s%s'.\n" % (tty_bold, g_sitename, tty_normal))
    sys.stdout.write("  The default web UI is available at %shttps://%s/%s/%s\n" % (tty_bold, hostname(), g_sitename, tty_normal))
    sys.stdout.write("\n")
    sys.stdout.write("  The admin user for the web applications is %somdadmin%s with password: %s%s%s\n" % (tty_bold, tty_normal, tty_bold, admin_password, tty_normal))
    sys.stdout.write("  (It can be changed with the '%sset_admin_password%s' command as site user)\n"  %(tty_bold, tty_normal))
    sys.stdout.write("\n")
    sys.stdout.write("  Please do a %ssu - %s%s for administration of this site.\n" % (tty_bold, g_sitename, tty_normal))
    sys.stdout.write("\n")

def main_init(args, options):
    if not site_is_disabled(g_sitename):
        bail_out(tty_error + ": Cannot initialize site that is not disabled.\n"
                 "Please call 'omd disable %s' first." % g_sitename)

    if not site_is_empty(g_sitename):
        if not opt_force:
            bail_out(tty_error + ": The site's home directory is not empty. Please add use\n"
                     "'omd --force init %s' if you want to erase all data." % g_sitename)

        sitedir = site_dir(g_sitename)
        # We must not delete the directory itself, just its contents.
        # The directory might be a separate filesystem. This is not quite
        # unlikely, since people using 'omd init' are doing this most times
        # because they are working with clusters and separate filesystems for
        # each site.
        sys.stdout.write("Wiping the contents of %s..." % sitedir)
        for entry in os.listdir(sitedir):
            if entry not in [ '.', '..' ]:
                path = sitedir + "/" + entry
                if opt_verbose:
                    sys.stdout.write("\n   deleting %s..." % path)
                if os.path.islink(path) or not os.path.isdir(path):
                    os.remove(path)
                else:
                    shutil.rmtree(sitedir + "/" + entry)
        ok()


    # Do the things that have been ommited on omd create --disabled
    admin_password = init_site(config_settings=None, options=options)
    welcome_message(admin_password)

def init_site(config_settings = None, options={}):
    apache_reload = options.apache_reload

    # Create symbolic link to version
    create_version_symlink(g_sitename, OMD_VERSION)

    # Build up directory structure with symbolic links relative to
    # the version link we just create
    for d in [ 'bin', 'include', 'lib', 'share' ]:
        os.symlink("version/" + d, g_sitedir + "/" + d)

    # Create skeleton files of non-tmp directories
    create_skeleton_files(g_sitename, '.')

    # Set the initial password of the default admin user
    admin_password = calculate_admin_password(options)
    set_admin_password(admin_password)

    # Change ownership of all files and dirs to site user
    chown_tree(g_sitedir, g_sitename)

    load_site_conf() # load default values from all hooks
    if config_settings: # add specific settings
        for hook_name, value in list(config_settings.items()):
            g_site_conf[hook_name] = value
    create_config_environment()

    # Change the few files that config save as created as root
    chown_tree(g_sitedir, g_sitename)

    finalize_site("create", apache_reload)

    return admin_password


# Is being called at the end of create, cp and mv.
# What is "create", "mv" or "cp". It is used for
# running the appropriate hooks.
def finalize_site(what, apache_reload):

    am_root = os.getuid() == 0

    # Now we need to do a few things as site user. Note:
    # - We cannot use setuid() here, since we need to get back to root.
    # - We cannot use seteuid() here, since the id command call will then still
    #   report root and confuse some tools
    # - We cannot sue setresuid() here, since that is not supported an Python 2.4
    # So we need to fork() and use a real setuid() here and leave the main process
    # at being root.
    pid = os.fork()
    if pid == 0:
        try:
            # From now on we run as normal site user!
            if am_root:
                switch_to_site_user()

            # Mount and create contents of tmpfs. This must be done as normal
            # user. We also could do this at 'omd start', but this might confuse
            # users. They could create files below tmp which would be shadowed
            # by the mount.
            save_site_conf()
            prepare_and_populate_tmpfs(g_sitename)

            # Run all hooks in order to setup things according to the
            # configuration settings
            config_set_all()
            save_site_conf()
            config_set_all()

            call_scripts('post-' + what, args=[g_sitename, OMD_VERSION])
            sys.exit(0)
        except Exception as e:
            bail_out(tty_error + ": finalize_site: %s" % e)
    else:
        wpid, status = os.waitpid(pid, 0)
        if status:
            bail_out(tty_error + ": Error in non-priviledged sub-process.")

    # Finally reload global apache - with root permissions - and
    # create include-hook for Apache and reload apache
    if am_root:
        # drwxr-x---. 1 <sitename> omd
        # sites can read each other's config files (expecially for port numbers), but world can not.
        os.chown(g_sitedir, user_id(g_sitename), group_id("omd"))
        os.chmod(g_sitedir, stat.S_IRWXU|stat.S_IRGRP|stat.S_IXGRP)

        create_apache_hook(g_sitename)
        if apache_reload:
            reload_apache()
        else:
            restart_apache()


def main_rm(args, options={}):
    # omd rm is called as root but the init scripts need to be called as
    # site user but later steps need root privilegies. So a simple user
    # switch to the site user would not work. Better create a subprocess
    # for this dedicated action and switch to the user in that subprocess

    if not call_scripts('pre-rm-root', args=[g_sitename, OMD_VERSION]):
        sys.stdout.write("update canceled by pre-rm script\n\n")
        sys.exit(1)

    os.system('omd stop %s' % g_sitename)

    reuse = options.reuse
    kill = options.kill

    if user_logged_in(g_sitename):
        if not kill:
            bail_out(tty_error + ": User '%s' still logged in or running processes." % g_sitename)
        else:
            kill_site_user_processes(exclude_current_and_parents=True)

    if tmpfs_mounted(g_sitename):
        unmount_tmpfs(g_sitename, kill=kill)

    if not reuse:
        remove_from_fstab(g_sitename)
        sys.stdout.write("Deleting user and group %s..." % g_sitename)
        os.chdir("/") # Site dir not longer existant after userdel
        userdel(g_sitename)
        ok()

    if os.path.exists(g_sitedir): # should be done by userdel
        sys.stdout.write("Deleting all data (%s)..." % g_sitedir)
        shutil.rmtree(site_dir(g_sitename))
        ok()

    if reuse:
        create_site_dir(g_sitename)
        os.mkdir(tmp_dir(g_sitename))
        os.chown(tmp_dir(g_sitename), user_id(g_sitename), group_id(g_sitename))

    # remove include-hook for Apache and tell apache
    delete_apache_hook(g_sitename)
    if options.apache_reload:
        reload_apache()
    else:
        restart_apache()

    call_scripts('post-rm-root', prefix=omd_root(), args=[g_sitename, OMD_VERSION])

def create_site_dir(sitename):
    os.makedirs(site_dir(sitename))
    os.chown(site_dir(sitename), user_id(sitename), group_id(sitename))


def site_is_disabled(g_sitename):
    apache_conf = "/omd/apache/%s.conf" % g_sitename
    return not os.path.exists(apache_conf)

def site_needs_update(g_sitename):
    return os.path.exists(os.path.join("/omd/apache/%s.conf" % g_sitename, ".backup_meta"))

def main_disable(args, options):
    if site_is_disabled(g_sitename):
        sys.stderr.write("This site is already disabled.\n")
        sys.exit(0)

    if not site_is_stopped(g_sitename):
        os.system('omd stop %s' % g_sitename)

    unmount_tmpfs(g_sitename, options.kill)
    sys.stdout.write("Disabling Apache configuration for this site...")
    delete_apache_hook(g_sitename)
    ok()
    restart_apache()

def main_enable(args, options):
    if not site_is_disabled(g_sitename):
        sys.stderr.write("This site is already enabled.\n")
        sys.exit(0)
    sys.stdout.write("Re-enabling Apache configuration for this site...")
    create_apache_hook(g_sitename)
    ok()
    if options.apache_reload:
        reload_apache()
    else:
        restart_apache()

def main_diag(args, options={}):
    options = [
        ("check",    "Run selfcheck"),
        ("shell",    "Open a shell for manual diagnosis"),
        ("exit",     "Exit diagnosis mode")
    ]
    ask_again = True
    choice = None
    errors = 0
    global g_sitename
    while ask_again:
        errors = 0
        if len(args) > 1:
            g_sitename = args[0]
            g_sitedir = site_dir(g_sitename)
            choice = args[1]
            ask_again = False
        elif len(args) > 0:
            choice = args[0]
            ask_again = False
        else:
            choice = ask_user_choices(
                'OMD diagnosis',
                'Here you find some support options.',
                options
            )
        if os.getuid() != 0:
            g_sitename = site_name()
            g_sitedir = site_dir(g_sitename)
        if g_sitename and site_exists(g_sitename):
            clear_environment()
            set_site_globals()
            set_environment()
        if choice == 'exit':
            ask_again = False
        if choice == 'check':
            for key, val in g_info.items():
                putenv("OMD_DIST_"+key, val)
            sys.stdout.write(tty_bold + "Running system checks:" + tty_normal+"\n")
            sys.stdout.write(("-"*50) +"\n")
            sys.stdout.write(tty_bold + "Versions:" + tty_normal+"\n")
            path = omd_root() + "/lib/omd/scripts/diag"
            scripts = os.listdir(path)
            scripts.sort()
            for f in scripts:
                if not f.startswith("version_"):
                    continue
                errors += call_diag_script('%s/%s' % (path, f))

            sys.stdout.write(("-"*50) +"\n")
            sys.stdout.write(tty_bold + "System:" + tty_normal+"\n")
            for f in scripts:
                if not f.startswith("system_"):
                    continue
                errors += call_diag_script('%s/%s' % (path, f))

            if g_sitename and site_exists(g_sitename):
                sys.stdout.write(("-"*50) +"\n")
                sys.stdout.write(tty_bold + ("Site %s:" % g_sitename) + tty_normal+"\n")
                for f in scripts:
                    if not f.startswith("site_"):
                        continue
                    errors += call_diag_script('%s/%s' % (path, f))

            # print summary
            sys.stdout.write(("-"*50) +"\n")
            if errors > 0:
                sys.stdout.write(tty_error + " total issues: %d\n" % errors)
            else:
                sys.stdout.write(tty_ok + " no issues found\n")
        elif choice == "shell":
            sys.stdout.write("\n Starting BASH. Type CTRL-D to continue.\n\n")
            os.system("cd '/omd' ; bash -i")
    if errors > 0:
        sys.exit(1)
    sys.exit(0)

# diag scripts can either set the exit code to != 0 to indicate an error
# or prefix each line with OK, ERROR or VERSION
def call_diag_script(script):
    errors = 0
    p = subprocess.Popen([script], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    exitcode = p.wait()
    output = p.communicate()
    for line in output[0].decode("UTF-8").splitlines():
        if line.startswith("OK"):
            sys.stdout.write("  " + tty_ok + " %s\n" % line[3:])
        elif line.startswith("ERROR"):
            sys.stdout.write("  " + tty_error + " %s\n" % line[6:])
            errors += 1
        elif line.startswith("VERSION"):
            info = re.split(r'\s+', line[8:], 1)
            sys.stdout.write('     %-7s %s\n' % (info[0].strip(), info[1].strip()))
        elif exitcode == 0:
            sys.stdout.write("  " + tty_ok + " %s\n" % line)
        else:
            sys.stdout.write("  " + tty_error + " %s\n" % line)
            errors += 1
    sys.stderr.write(output[1].decode("UTF-8"))
    return(errors)

def set_conflict_option(options):
    global opt_conflict
    opt_conflict = "conflict" in options and options.conflict or "ask"

    if opt_conflict not in [ "ask", "install", "keepold", "abort" ]:
        bail_out(tty_error + ": Argument to --conflict must be one of ask, install, keepold and abort.")


def get_exclude_patterns(options):
    excludes = []
    if options.no_rrds or options.no_past:
        excludes.append("var/pnp4nagios/perfdata/*")
        excludes.append("var/pnp4nagios/spool/*")
        excludes.append("var/rrdcached/*")
        excludes.append("var/pnp4nagios/states/*")

    if options.no_dbs or options.no_past:
        excludes.append("var/mysql/*")
        excludes.append("var/influxdb/*")
        excludes.append("var/victoriametrics/*")
        excludes.append("var/prometheus/*")
        excludes.append("var/top/*")
        excludes.append("var/tmp/*")
        excludes.append("var/gearmand.db")
        excludes.append("var/thruk/obj_retention.*")
        excludes.append("var/naemon/objects.*cache")

    if options.no_logs or options.no_past:
        excludes.append("var/log/*")
        excludes.append("var/log/*/*")
        excludes.append("var/nagios/nagios.log")
        excludes.append("var/nagios/archive/*")
        excludes.append("var/naemon/archive/*")
        excludes.append("var/naemon/naemon.log")
        excludes.append("var/icinga/archive/*")
        excludes.append("var/pnp4nagios/log/*")
        excludes.append("var/pnp4nagios/perfdata.dump")
        excludes.append("var/mkeventd/history/*")
        excludes.append("var/check_mk/core/history")
        excludes.append("var/check_mk/core/archive/*")

    if options.no_tmp or options.no_tmp:
        excludes.append("tmp/*")

    # add user supplied excludes
    if options.exclude != None:
        excludes.extend(options.exclude)

    return excludes


def main_mv_or_cp(what, args, options={}):
    set_conflict_option(options)
    action = what == "mv" and "rename" or "copy"

    global g_sitename
    global g_sitedir
    if len(args) != 1:
        bail_out(tty_error + ": omd: Usage: omd %s oldname newname" % what)
    new = args[0]

    reuse = False
    if options.reuse:
        reuse = True
        if not user_verify(new):
            bail_out(tty_error + ": Error verifying site user.")
        fstab_verify(new)

    sitename_must_be_valid(new, reuse)

    old = g_sitename
    if not site_is_stopped(old):
        if what == "cp":
            sys.stdout.write("Warning: The site should be stopped when creating a copy.\n")
        else:
            bail_out(tty_error + ": Cannot %s site '%s' while it is running." % (action, old))

    pids = find_processes_of_user(old)
    if pids:
        bail_out(tty_error + ": Cannot %s site '%s' while there are processes owned by %s.\n"
                 "PIDs: %s" % (action, old, old, " ".join(pids)))

    if what == "mv":
        unmount_tmpfs(old, kill = options.kill)
        if not reuse:
            remove_from_fstab(old)

    sys.stdout.write("%sing site %s to %s...\n" % (what == "mv" and "Mov" or "Copy", old, new))
    sys.stdout.flush()

    # Create new user. Note: even on mv we need to create a new user.
    # Linux does not (officially) allow to rename a user.
    uid = options.uid
    gid = options.gid
    if not reuse:
        useradd(new, uid, gid) # None for uid/gid means: let Linux decide

    if what == "mv" and not reuse:
        # Rename base directory and apache config
        os.rename(site_dir(old), site_dir(new))
        delete_apache_hook(old)
    else:
        # Make exact file-per-file copy with same user but already new name
        if not reuse:
            os.mkdir(site_dir(new))

        addopts = ""
        for p in get_exclude_patterns(options):
            addopts += " --exclude '/%s'" % p

        if opt_verbose:
            addopts += " -v"

        os.system("rsync -ax %s '%s/' '%s/'" %
                (addopts, site_dir(g_sitename), site_dir(new)))

    # give new user all files
    chown_tree(site_dir(new), new)

    # Change config files from old to new site (see rename_site())
    patch_skeleton_files(g_sitename, new)

    # In case of mv now delete old user
    if what == "mv" and not reuse:
        userdel(old)

    # clean up old site
    if what == "mv" and reuse:
        g_sitename = old
        main_rm([], options)

    sys.stdout.write("OK\n")

    # Now switch over to the new site as currently active site
    g_sitename = new
    set_site_globals()
    set_environment()

    # Entry for tmps in /etc/fstab
    if not reuse:
        add_to_fstab(new, tmpfs_size = options.tmpfs_size)

    finalize_site(what, options.apache_reload)



def main_diff(args, options={}):
    set_conflict_option(options)
    from_version  = site_version(g_sitename)
    from_skelroot = "/omd/versions/%s/skel" % from_version

    # If arguments are added and those arguments are directories,
    # then we just output the general state of the file. If only
    # one file is specified, we directly show the unified diff.
    # This behaviour can also be forced by the OMD option -v.

    if len(args) == 0:
        args = ["."]
    elif len(args) == 1 and os.path.isfile(args[0]):
        global opt_verbose
        opt_verbose = True

    global bare
    bare = options.bare # sorry for the global variable here

    changed = 0
    for arg in args:
        changed += diff_list(from_skelroot, g_sitedir, from_version, arg)
    sys.exit(1 if changed > 0 else 0)


def main_vimdiff(args, options={}):
    set_conflict_option(options)
    from_version  = site_version(g_sitename)
    from_skelroot = "/omd/versions/%s/skel" % from_version

    global bare
    bare = "" # sorry for the global variable here
    global opt_verbose
    opt_verbose = True

    if len(args) == 0:
        bail_out(tty_error + ": Sorry, 'omd vimdiff' requires a filename as argument.")

    for arg in args:
        diff_list(from_skelroot, g_sitedir, from_version, arg, "vimdiff")

def main_reset(args, options={}):
    sitedir = site_dir(g_sitename)

    if len(args) == 0:
        bail_out(tty_error + ": Sorry, 'omd reset' requires a filename as argument.")

    replacements = {
        "###SITE###" : g_sitename,
        "###ROOT###" : sitedir,
    }
    for hook_name in g_site_conf:
        replacements["###CONFIG_%s###" % hook_name] = g_site_conf[hook_name]
    skelroot = omd_root() + "/skel"
    read_skel_permissions()

    for arg in args:
        if not os.path.exists(skelroot + '/' + arg):
            bail_out(tty_error + ": file %s does not exist in skeleton"  % (arg))
        if os.path.isdir(skelroot + '/' +arg) and not os.path.islink(skelroot + '/' + arg):
            for dirpath, dirnames, filenames in os.walk(skelroot + '/' +arg):
                localpath = dirpath.replace(skelroot, sitedir).replace(sitedir+"/", "")
                for entry in dirnames:
                    if os.path.exists(localpath + '/' + entry) and not os.path.isdir(localpath + '/' + entry):
                        try:
                            os.remove(localpath + '/' + entry)
                        except Exception:
                            pass
                for entry in filenames:
                    try:
                        os.remove(localpath + '/' + entry)
                    except Exception:
                        pass
                    os.makedirs(localpath, exist_ok=True)
                    create_skeleton_file(skelroot, sitedir, localpath + '/' + entry, replacements)
        else:
            try:
                os.remove(arg)
            except Exception:
                pass
            create_skeleton_file(skelroot, sitedir, arg, replacements)

    config_set_all()


def diff_list(from_skelroot, g_sitedir, from_version, orig_path, diff_binary = None):
    # Compare a list of files/directories with the original state
    # and output differences. If opt_verbose then we output the complete
    # diff, otherwise just the state. Only files present in skel/ are
    # handled at all.

    read_skel_permissions()
    old_perms = load_skel_permissions(from_version)

    # Prepare paths:
    # orig_path: this was specified by the user
    # rel_path:  path relative to the site's dir
    # abs_path:  absolute path

    # Get absolute path to site dir. This can be (/opt/omd/sites/XXX)
    # due to the symbolic link /omd
    old_dir = os.getcwd()
    os.chdir(g_sitedir)
    abs_sitedir = os.getcwd()
    os.chdir(old_dir)

    # Create absolute paths first
    abs_path = orig_path
    if not abs_path.startswith("/"):
        if abs_path == ".":
            abs_path = ""
        elif abs_path.startswith("./"):
            abs_path = abs_path[2:]
        abs_path = os.getcwd() + "/" + abs_path
    abs_path = abs_path.rstrip("/")

    # Make sure that path does not lie outside the OMD site
    if abs_path.startswith(g_sitedir):
        rel_path = abs_path[len(g_sitedir) + 1:]
    elif abs_path.startswith(abs_sitedir):
        rel_path = abs_path[len(abs_sitedir) + 1:]
    else:
        bail_out(tty_error + ": Sorry, 'omd diff' only works for files in the site's directory.")

    changed = 0
    def print_diff_and_count(rel_path, source_path, target_path, source_version, source_perms, diff_binary = None):
        if print_diff(rel_path, source_path, target_path, source_version, source_perms, diff_binary = None):
            nonlocal changed
            changed += 1

    if not os.path.isdir(abs_path):
        print_diff_and_count(rel_path, from_skelroot, g_sitedir, from_version, old_perms, diff_binary)
    else:
        if not rel_path:
            rel_path = "."
        walk_skel(from_skelroot, print_diff_and_count, (from_skelroot, g_sitedir,
                  from_version, old_perms), {}, depth_first=False, relbase = rel_path)
    return changed


def print_diff(rel_path, source_path, target_path, source_version, source_perms, diff_binary = None):
    source_file = source_path + '/' + rel_path
    target_file = target_path + '/' + rel_path

    source_perm = get_skel_permissions(source_version, source_perms, rel_path)
    target_perm = get_file_permissions(target_file)

    source_type = filetype(source_file)
    target_type = filetype(target_file)

    changed_type, changed_content, changed = file_status(source_file, target_file)

    if not changed:
        return False

    fn = tty_bold + rel_path + tty_normal
    if bare:
        fn = rel_path

    def print_status(color, f, status, long_out):
        if bare:
            sys.stdout.write("%s %s\n" % (status, f))
        else:
            sys.stdout.write(color + " %s %s\n" % (long_out, f))

        if opt_verbose:
            arrow = tty_magenta + '->' + tty_normal
            if status == 'sc':
                sys.stdout.write("    %s %s %s\n" % (os.readlink(source_file), arrow, os.readlink(target_file)))
            elif 'c' in status:
                source_content = instantiate_skel(source_file)
                if diff_binary:
                    skel_tmp_file = target_file + '.skel_default'
                    open(skel_tmp_file, "wb").write(source_content)
                    os.system("%s %s %s" % (diff_binary, target_file, skel_tmp_file))
                    os.remove(skel_tmp_file)
                else:
                    if 0 == os.system("which colordiff > /dev/null 2>&1"):
                        diff = "colordiff"
                    else:
                        diff = "diff"
                    process = subprocess.Popen([diff, '-u', '-', target_file], stdin=subprocess.PIPE)
                    if isinstance(source_content, str):
                        source_content = source_content.encode()
                    process.stdin.write(source_content)
                    process.stdin.close()
                    process.wait()
            elif status == 'p':
                sys.stdout.write("    %04o %s %04o\n" % (source_perm, arrow, target_perm))
            elif 't' in status:
                sys.stdout.write("    %s %s %s\n" % (source_type, arrow, target_type))

    if not target_type:
        print_status(good, fn, 'd', 'Deleted')
        return True

    elif changed_type and changed_content:
        print_status(good, fn, 'tc', 'Changed type and content')

    elif changed_type and not changed_content:
        print_status(good, fn, 't', 'Changed type')

    elif source_type == "link" and changed_content:
        print_status(good, fn, 'sc', 'Symbolic link changed')

    elif changed_content and not changed_type:
        print_status(good, fn, 'c', 'Changed content')

    if source_perm != target_perm:
        print_status(warn, fn, 'p', 'Changed permissions')

    return True



def main_update(args, options={}):
    os.chdir(g_sitedir)
    set_conflict_option(options)

    if int(os.popen("df -Pm /omd/sites/%s/. | tail -n 1 | awk '{ print $4 }'" % g_sitename).read()) < 100:
        bail_out(tty_error + ": Not enough free disk space. Pleace free at least 100MB!")

    # Source version: the version of the site we deal with
    from_version = site_version(g_sitename)

    # Target version: the version of the OMD binary
    to_version = OMD_VERSION

    backup_skel_path = os.path.join(g_sitedir, ".backup_meta")

    # source and target are identical if 'omd update' is called
    # from within a site. In that case we make the user choose
    # the target version explicitely and the re-exec the bin/omd
    # of the target version he has choosen.
    if from_version == to_version and not os.path.exists(os.path.join(backup_skel_path, 'skel')):
        possible_versions = [ v for v in omd_versions() if v != from_version ]
        possible_versions.sort(reverse=True)
        if len(possible_versions) == 0:
            bail_out(tty_error + ": There is no other OMD version to update to.")
        elif opt_version:
            to_version = opt_version
        elif len(possible_versions) == 1:
            to_version = possible_versions[0]
        else:
            ok, to_version = dialog_menu("Choose target version",
                    "Please choose the version this site should be updated to",
                    [ (v, "Version %s" % v) for v in possible_versions ],
                    possible_versions[0],
                    "Update now",
                    "Cancel")
            if not ok:
                bail_out("Aborted.")
        exec_other_omd(to_version)

    # This line is reached, if the version of the OMD binary (the target)
    # is different from the current version of the site.
    if not options.dry_run and not opt_force and not dialog_yesno(
            "You are going to update:\n"
            "site: \Z5%s\Z0\n"
            "host: \Z5%s\Z0\n"
            "from: \Z5%s\Z0\n"
            "to:   \Z5%s\Z0\n"
            "This will include updating all of you configuration files and merging "
            "changes in the default files with changes made by you. In case of conflicts "
            "your help will be needed." % (g_sitename, hostname(), from_version, to_version),
            "Update!", "Abort"):
        bail_out("Aborted.")

    hot_update = False
    if not options.dry_run and not site_is_stopped(g_sitename):
        hot_update = True
        if not options.force:
            bail_out(tty_error + ": Please completely stop '%s' before updating it." % g_sitename)

    # show one extra confirmation dialog when updating from 1.x/2.x to 3.x
    if int(version_numeric(from_version)) != int(version_numeric(to_version)):
        if not options.dry_run and not opt_force and dialog_yesno(
            "\ZuMAJOR UPDATE\ZU\n"
            "You are going to update:\n"
            "site: \Z5%s\Z0\n"
            "host: \Z5%s\Z0\n"
            "from: \Z5%s\Z0\n"
            "to:   \Z5%s\Z0\n"
            "Please read the migration guide at: https://labs.consol.de/omd/migration_%s.html "
            "and ensure you have a backup. You have been warned." % (g_sitename, hostname(), from_version, to_version, to_version[:1]),
            "Abort", "Continue"):
            bail_out("Aborted.")
        if hot_update:
            bail_out("Hot updates not possible on major version updates.")

    if not options.dry_run and args:
        bail_out("Path arguments allowed only in dry-run mode.")

    # Unmount tmp. We need to recreate the files and directories
    # from the new version after updating.
    if not hot_update and not options.dry_run:
        unmount_tmpfs(g_sitename)

    if not options.dry_run:
        start_logging(g_sitedir + '/var/log/update.log')

    sys.stdout.write("%s%s - Updating site '%s' from version %s to %s...\n\n" %
            ((options.dry_run and tty_yellow+"*DRY RUN* "+tty_normal or ""), time.strftime('%Y-%m-%d %H:%M:%S'), g_sitename, from_version, to_version))

    global g_conflicts
    g_conflicts = 0
    if options.dry_run:
        dry_run_path = os.path.join(g_sitedir, ".update_dry_run")
        putenv("OMD_UPDATE_DRY_RUN", dry_run_path)
        prepare_dry_run_update_path(dry_run_path, from_version, to_version)

    target_folder = g_sitedir
    if options.dry_run:
        target_folder = dry_run_path

    putenv("OMD_UPDATE_FROM_VERSION", from_version)
    putenv("OMD_UPDATE_TO_VERSION", to_version)
    putenv("OMD_UPDATE_BASE", target_folder)
    if not call_scripts('pre-update', prefix=("/omd/versions/%s" % to_version)):
        sys.stdout.write("update canceled by pre-update script\n\n")
        sys.exit(1)

    # Now apply changes of skeleton files. This can be done
    # in two ways:
    # 1. creating a patch from the old default files to the new
    #    default files and applying that to the current files
    # 2. creating a patch from the old default files to the current
    #    files and applying that to the new default files
    # We implement the first method.

    # read permissions
    read_skel_permissions()
    old_perms = load_skel_permissions(from_version)

    from_skelroot = "/omd/versions/%s/skel" % from_version
    to_skelroot = "/omd/versions/%s/skel" % to_version

    if os.path.exists(os.path.join(backup_skel_path, 'skel')):
        from_skelroot = os.path.join(backup_skel_path, 'skel')
        sys.stdout.write("using backup skeleton path from: '%s'\n" % backup_skel_path)
        old_perms = load_skel_permissions_for_path(backup_skel_path+'/skel.permissions')

    # First walk through skeleton files of new version
    walk_skel(to_skelroot, update_file, (from_version, to_version, target_folder, old_perms, from_skelroot), { "dry_run":options.dry_run}, depth_first=False, filter=args)

    # Now handle files present in old but not in new skel files
    walk_skel(from_skelroot, update_file, (from_version, to_version, target_folder, old_perms, from_skelroot), { "dry_run":options.dry_run}, depth_first=True, exclude_if_in = to_skelroot, filter=args)

    # Change symbolic link pointing to new version
    if not options.dry_run:
        if hot_update :
            init_action("stop", [], options)
            unmount_tmpfs(g_sitename)
        create_version_symlink(g_sitename, to_version)

    # Let hooks do their work and update configuration.
    if not options.dry_run:
        load_site_conf()
        create_config_environment()
        config_set_all()
        save_site_conf()

        if os.path.exists(backup_skel_path):
            shutil.rmtree(backup_skel_path)

    call_scripts('post-update', prefix=("/omd/versions/%s" % to_version))

    sys.stdout.write('%sFinished update.\n\n' % ((options.dry_run and tty_yellow+"*DRY RUN* "+tty_normal or "")))

    if options.dry_run:
        if os.path.exists(dry_run_path):
            shutil.rmtree(dry_run_path)
        if g_conflicts > 0:
            sys.stdout.write(tty_error + " %d conflicts during dry run update\n" % g_conflicts)
            if not args:
                sys.stdout.write("(get more details by running omd update -n -v <FILE>)\n")
            sys.exit(1)
        else:
            sys.stdout.write(tty_ok + " %d conflicts during dry run update\n" % g_conflicts)
            sys.exit(0)
    else:
        if hot_update :
            sys.stdout.write('starting all services after update.\n')
            init_action("start", [], options)
        sync_apache_maint_page(g_sitename)
        stop_logging()


def prepare_dry_run_update_path(dry_run_path, from_version, to_version):
    from_skel_path = os.path.join("/omd/versions", from_version, "skel")
    to_skel_path   = os.path.join("/omd/versions", to_version,   "skel")

    # create list of required files:
    # all files that exist in the current site and either exist in the old or new skel folder
    sync_files = ['tmp', 'bin', 'include', 'lib', 'share', 'version' ]
    for (dir) in [from_skel_path, to_skel_path]:
        dirlen = len(dir)+1
        for (root,dirs,files) in os.walk(dir):
            for file in files + dirs:
                file = os.path.join(root, file)[dirlen:]
                if os.path.lexists(file):
                    sync_files.append(file)
    sync_files = sorted(list(set(sync_files)))

    # remove previous run
    if os.path.exists(dry_run_path):
        shutil.rmtree(dry_run_path)
    os.mkdir(dry_run_path)

    sync_files_path = os.path.join(dry_run_path, '.sync_files')
    open(sync_files_path, "w").write("\n".join(sync_files))

    if 0 != os.system("rsync -ax --files-from=%s '%s/.' '%s/.'" % (sync_files_path, site_dir(g_sitename), dry_run_path)):
        bail_out(tty_error + ": Cannot create tmp directory for dry-run update.")

    # create empty files for all files which exist in the current site to simulate ex.: non empty obsolete folders
    for (root,dirs,files) in os.walk('.', topdown=True):
        if root.startswith("./"):
            root = root[2:]
        # skip folders which are neither in old or new skel to avoid deep recursion into custom folder
        if not os.path.lexists(os.path.join(from_skel_path, root)) and not os.path.lexists(os.path.join(to_skel_path, root)):
            continue
        for dir in dirs:
            if not os.path.lexists(os.path.join(from_skel_path,root, dir)) and not os.path.lexists(os.path.join(to_skel_path, root, dir)):
                dirs.remove(dir)
        for dir in dirs:
            dir = os.path.join(root, dir)
            if not os.path.lexists(os.path.join(dry_run_path, dir)):
                os.mkdir(os.path.join(dry_run_path, dir))
        for file in files:
            file = os.path.join(dry_run_path, root, file)
            if not os.path.lexists(file):
                with open(file, 'w') as fp:
                    pass

    return

def main_mount(args, options = {}):
    global g_sitename
    global g_sitedir

    # if no site is selected, all sites are affected
    exit_status = 0
    if not g_sitename:
        for site in all_sites():
            # Set global vars for the current site
            g_sitename = site
            g_sitedir = site_dir(g_sitename)
            load_site_conf()

            if opt_version and site_version(site) != opt_version:
                continue

            # already mounted
            if tmpfs_mounted(g_sitename):
                sys.stderr.write("Cannot mount tmpfs of site '%s': already mounted.\n" % site)
                continue

            # Skip the site even when it is partly running
            if not site_is_stopped(site):
                sys.stderr.write("Cannot mount tmpfs of site '%s' while it is running.\n" % site)
                continue

            sys.stdout.write("%sMounting tmpfs of site %s%s..." % (tty_bold, site, tty_normal))
            sys.stdout.flush()

            # We need to open a subprocess, because each site must be populated with the account of the
            # site user. And after setuid() we cannot return.
            stdout = sys.stdout
            stderr = sys.stderr
            p = subprocess.Popen(
                [sys.argv[0], "mount" ] + [ site ] + args,
                stdin=open(os.devnull, "r"),
                stdout=stdout,
                stderr=stderr
            )

            if not p.wait():
                exit_status = 1
    else:
        # Skip the site even when it is partly running
        if not site_is_stopped(g_sitename):
            bail_out(tty_error + ": Cannot mount tmpfs of site '%s' while it is running." % g_sitename)
        if not prepare_and_populate_tmpfs(g_sitename):
            exit_status = 1
    sys.exit(exit_status)

def main_umount(args, options = {}):
    global g_sitename
    global g_sitedir

    # if no site is selected, all sites are affected
    exit_status = 0
    if not g_sitename:
        for site in all_sites():
            # Set global vars for the current site
            g_sitename = site
            g_sitedir = site_dir(g_sitename)

            if opt_version and site_version(site) != opt_version:
                continue

            # Skip the site even when it is partly running
            if not site_is_stopped(site):
                sys.stderr.write("Cannot unmount tmpfs of site '%s' while it is running.\n" % site)
                continue

            sys.stdout.write("%sUnmounting tmpfs of site %s%s..." % (tty_bold, site, tty_normal))
            sys.stdout.flush()

            if not show_success(unmount_tmpfs(site, False, kill=options.kill)):
                exit_status = 1
    else:
        # Skip the site even when it is partly running
        if not site_is_stopped(g_sitename):
            bail_out(tty_error + ": Cannot unmount tmpfs of site '%s' while it is running." % g_sitename)
        unmount_tmpfs(g_sitename, kill=options.kill)
    sys.exit(exit_status)

def main_init_action(command, args, options={}):
    if g_sitename:
        exit_status = init_action(command, args, options)
        sys.exit(exit_status)

    # if no site is selected, all sites are affected

    bare     = options.bare
    parallel = options.parallel

    max_site_len = max([ 8 ] + [ len(site_id) for site_id in all_sites() ])

    def parallel_output(site_id, line):
        sys.stdout.write(("%-"+str(max_site_len)+"s - %s") % (site_id, line.decode("UTF-8")))

    exit_states, processes = [], []
    for site in all_sites():
        v = site_version(site)
        if v is None: # skip partially created sites
            continue

        if opt_version and v != opt_version:
            continue

        # Skip disabled sites completely
        if site_is_disabled(site):
            continue

        # Handle non autostart sites
        if command in [ "start", "restart", "reload" ] or \
            ( options.auto and command == "status" ):
            if not opt_force and not site_autostart(site):
                if bare:
                    continue
                elif not parallel:
                    sys.stdout.write("Ignoring site '%s': AUTOSTART != on\n" % site)
                else:
                    parallel_output(site, b"Ignoring since autostart is disabled\n")
                continue

        if command == "status" and bare:
            sys.stdout.write('[%s]\n' % site)
        elif not parallel:
            sys.stdout.write("%sDoing '%s' on site %s:%s\n" % (tty_bold, command, site, tty_normal))
        else:
            parallel_output(site, ("Invoking '%s'\n" % (command)).encode('UTF-8'))
        sys.stdout.flush()

        # We need to open a subprocess, because each site must be started with the account of the
        # site user. The logic for switching to the siteuser is in the main method
        stdout = sys.stdout if not parallel else subprocess.PIPE
        stderr = sys.stderr if not parallel else subprocess.STDOUT
        bare_arg = [ "--bare" ] if bare else []
        p = subprocess.Popen(
            [sys.argv[0], command ] + bare_arg + [ site ] + args,
            stdin=open(os.devnull, "r"),
            stdout=stdout,
            stderr=stderr
        )

        if parallel:
            import fcntl
            # Make the output non blocking
            fd = p.stdout.fileno()
            fl = fcntl.fcntl(fd, fcntl.F_GETFL)
            fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)

            processes.append((site, p))
        else:
            exit_states.append(p.wait())
            if not bare:
                sys.stdout.write("\n")

    # In parallel mode wait for completion of all processes and collect
    # the output produced on stdout in the meantime. Since the processes
    # work in parallel and we want to have nearly "live" output, we process
    # the output line by line and prefix each line with the ID of the site.
    # The output of a single process must not block the output of the others,
    # so it seems we need to do some low level stuff here :-/.
    site_buf = {}
    while parallel and processes:
        for site_id, p in processes[:]:
            buf = site_buf.get(site_id, b"")
            try:
                while True:
                    b = p.stdout.read(1024)
                    if not b:
                        break
                    buf += b
            except IOError as e:
                if e.errno == 11: # Resource temporarily unavailable
                    pass
                else:
                    raise

            while True:
                pos = buf.find(b"\n")
                if pos == -1:
                    break
                line, buf = buf[:pos+1], buf[pos+1:]
                parallel_output(site_id, line)

            site_buf[site_id] = buf

            if not buf and p.poll() is not None:
                exit_states.append(p.returncode)
                processes.remove((site_id, p))
        time.sleep(0.01)

    # Do not simply take the highest exit code from the single sites.
    # We want to be able to output the fact that either none of the
    # sites is running or just some of the sites. For this we transform
    # the sites states 1 (not running) to 2 (partially running) if at least
    # one other site has state 0 (running) or 2 (partially running).
    if 1 in exit_states and (0 in exit_states or 2 in exit_states):
        exit_status = 2 # not all sites running, but at least one
    elif exit_states:
        exit_status = max(exit_states)
    else:
        exit_status = 0 # No OMD site existing

    sys.exit(exit_status)

def main_config(args, options={}):
    if site_needs_update(g_sitename):
        bail_out(tty_error + ": This site needs to be updated with: omd update")

    load_config_hooks() # needed for all config commands
    if len(args) == 0:
        config_configure()
    else:
        command = args[0]
        args = args[1:]
        if command == "show":
            config_show(args)
        elif command == "set":
            config_set(args)
        elif command == "change":
            config_change()
        else:
            config_usage()

def main_su(args, options={}):
    try:
        os.execl("/bin/su", "su", "-", "%s" % g_sitename)
    except OSError:
        bail_out(tty_error + ": Cannot open a shell for user %s" % g_sitename)


def backup_site_files_to_taropen(tar, options):
    import fnmatch
    exclude = get_exclude_patterns(options)

    def filter_files(tarinfo):
        filename = tarinfo.name
        for glob_pattern in exclude:
            # patterns are relative to g_sitedir, filename is relative to /omd/site
            # strip of the g_sitename/ prefix from filename
            if fnmatch.fnmatch(filename[len(g_sitename)+1:], glob_pattern):
                return None # exclude this file
        if options.verbose:
            sys.stderr.write("adding %s\n" % filename[len(g_sitename)+1:])
        return tarinfo

    def print_files(tarinfo):
        filename = tarinfo.name
        if options.verbose:
            sys.stderr.write("adding %s\n" % filename[len(g_sitename)+1:])
        return tarinfo

    # add skel, it doesn't take much space and we can restore to any version with that information
    tar.add(os.path.join(g_sitedir, 'version', 'skel'), g_sitename+"/.backup_meta/skel", filter=print_files)
    tar.add(os.path.join(g_sitedir, 'share', 'omd', 'skel.permissions'), g_sitename+"/.backup_meta/skel.permissions", filter=print_files)
    if not exclude:
        tar.add(g_sitedir, g_sitename, filter=print_files)
    else:
        tar.add(g_sitedir, g_sitename, filter=filter_files)


def backup_site_to_taropen(fh, options):
    import tarfile
    tar = tarfile.open(fileobj=fh, mode='w:gz')
    try:
        # Add the version symlink as first file to be able to
        # check a) the sitename and b) the version before reading
        # the whole tar archive. Important for streaming.
        # The file is added twice to get the first for validation
        # and the second for excration during restore.
        tar.add(g_sitedir + "/version", g_sitename + "/version")
        backup_site_files_to_taropen(tar, options)
        tar.close()
    except IOError as e:
        bail_out(tty_error + ": Failed to perform backup: %s" % e)


def main_backup(args, options={}):
    if len(args) == 0:
        bail_out(tty_error + ": You need to provide a path to the destination file.")

    if site_needs_update(g_sitename):
        bail_out(tty_error + ": This site needs to be updated with: omd update")
    if not site_is_stopped(g_sitename):
        sys.stdout.write("Warning: The site should be stopped for a backup.\n")
        # exclude tmp/* from hot backups
        options.no_tmp = True

    elif tmpfs_mounted(g_sitename):
        unmount_tmpfs(g_sitename, kill = options.kill)

    dest = args[0]
    if dest == '-':
        bail_out(tty_error + ": backup to stdout not supported anymore")
    else:
        if dest[0] != '/':
            dest = g_orig_wd + '/' + dest
        fh = open(dest, 'wb')

    backup_site_to_taropen(fh, options)
    if options.verbose:
        sys.stderr.write("backup %s written\n" % dest)


def main_restore(args, options={}):
    import tarfile
    global g_sitename
    global g_sitedir
    set_conflict_option(options)

    if len(args) == 0:
        bail_out(tty_error + ": You need to provide a path to the source file.")

    source = args[-1]
    if source == '-':
        bail_out(tty_error + ": backup from stdin not supported anymore")
    elif os.path.exists(source):
        fh = open(source, "rb")
        tar_mode = 'r:gz'
    else:
        bail_out(tty_error + ": The backup archive does not exist.")

    try:
        tar = tarfile.open(fileobj=fh, mode=tar_mode)
    except tarfile.ReadError as e:
        bail_out(tty_error + ": Failed to open the backup: %s" % e)

    # Get the first file of the tar archive. Expecting <site>/version symlink
    # for validation reasons.
    site_tarinfo = tar.next()
    try:
        sitename, version_name = site_tarinfo.name.split("/", 1)
    except ValueError:
        bail_out(tty_error + ": Failed to detect version of backed up site. "
                 "Maybe the backup is from an incompatible version.")

    if version_name == "version":
        version = site_tarinfo.linkname.split('/')[-1]
    else:
        bail_out(tty_error + ": Failed to detect version of backed up site.")

    if not version_exists(version):
        backup_skel_tarinfo = tar.next()
        if backup_skel_tarinfo.name.find("/version/skel") == -1 and backup_skel_tarinfo.name.find("/.backup_meta/skel") == -1:
            bail_out(tty_error + ": This is an old incomplete backup and its version is not installed.\n"
                     "Either install version %s or create the backup manually with this command:\n"
                     "cd /omd/sites/ && tar cfz /tmp/$OMD_SITE.backup.tgz $OMD_SITE/version $OMD_SITE/version/skel $OMD_SITE/share/omd/skel.permissions $OMD_SITE\n"
                     % version)

    # Restore site with its original name, or specify a new one
    reuse = False
    new_sitename = sitename
    if len(args) == 2:
        new_sitename = args[0]

    am_root = os.getuid() == 0
    if not am_root:
        if new_sitename != sitename:
            bail_out(tty_error + ": Only root can restore to a new site!")
        reuse = True
        new_sitename = site_name()
        g_sitename = new_sitename
        set_site_globals()

    g_sitename = new_sitename
    g_sitedir  = site_dir(new_sitename)

    if options.reuse:
        reuse = True
        if not user_verify(g_sitename, allow_populated=True):
            bail_out(tty_error + ": Error verifying site user.")
        fstab_verify(g_sitename)

    sitename_must_be_valid(g_sitename, reuse)

    if reuse:
        version_hint = ""
        if not version_exists(version):
            version_hint = (
                "Since the version %s used in the backup is not installed, an "
                "automatic update to version %s will be done. "
                "This will include updating all of you configuration files and merging "
                "changes in the default files with changes made by you. In case of conflicts "
                "your help will be needed." % (version, OMD_VERSION)
            )
        if not opt_force and not dialog_yesno(
            "You are going to restore the site %s from backup %s. "
            "The site will be completly removed and restored! %s"
            % (g_sitename, source, version_hint),
            "Restore!", "Abort"):
            bail_out("Aborted.")

    if reuse:
        if not site_is_stopped(g_sitename):
            if not options.kill:
                bail_out(tty_error + ": Cannot restore '%s' while it is running." % (g_sitename))
            else:
                if am_root:
                    os.system('omd stop %s' % g_sitename)
                else:
                    os.system('omd stop')
        unmount_tmpfs(g_sitename, kill = options.kill)

    sys.stdout.write("Restoring site %s from %s...\n" %
                    (g_sitename, source == '-' and 'stdin' or source))
    sys.stdout.flush()

    if not reuse:
        uid = options.uid
        gid = options.gid
        useradd(g_sitename, uid, gid) # None for uid/gid means: let Linux decide
    else:
        sys.stdout.write("Deleting existing site data...")
        # remove site folder (when doing this as user, skip only on errors below the sitefolder itself)
        shutil.rmtree(g_sitedir, onerror=lambda f,p,e: p != g_sitedir and not am_root and bail_out(tty_error + ": %s" % e[1]))
        ok()

    if not os.path.exists(g_sitedir):
        os.mkdir(g_sitedir)

    # Now extract all files
    for tarinfo in tar:
        # remove leading site name from paths
        tarinfo.name = '/'.join(tarinfo.name.split('/')[1:])
        tarinfo.name = re.sub("^version/skel", ".backup_meta/skel", tarinfo.name)
        tarinfo.name = re.sub("^share/omd/skel.permissions", ".backup_meta/skel.permissions", tarinfo.name)
        if opt_verbose:
            sys.stdout.write("Restoring %s...\n" % tarinfo.name)
        if tarinfo.issym() or tarinfo.islnk():
            parts = tarinfo.linkname.split('/')
            if tarinfo.name == 'version' and tarinfo.linkname == sitename+'/version':
                continue
            if parts[0] == sitename:
                parts = parts[1:]
            tarinfo.linkname = '/'.join(parts)

        # workaround https://bugs.python.org/issue40049
        if tarinfo.issym():
            targetpath = os.path.join(g_sitedir, tarinfo.name)
            if os.path.lexists(targetpath):
                os.unlink(targetpath)

        # workaround: https://peps.python.org/pep-0706/#backporting-forward-compatibility
        if hasattr(tarfile, 'data_filter'):
            tar.extract(tarinfo, path=g_sitedir, filter='tar')
        else:
            tar.extract(tarinfo, path=g_sitedir)
    tar.close()

    # give new user all files
    if am_root:
        chown_tree(g_sitedir, g_sitename)

    load_site_conf(skipMissing=True)

    # Change config files from old to new site (see rename_site())
    backup_skel_path = os.path.join(g_sitedir, ".backup_meta")
    if sitename != g_sitename:
        if os.path.exists(backup_skel_path):
            patch_skeleton_files(sitename, g_sitename, backup_skel_path+'/skel')
        else:
            patch_skeleton_files(sitename, g_sitename)

    # perform an update to current version
    # this is neccessary if old restored omd version does not exist
    # or there were platform specific changes, for example when restoring
    # from a apache 2.2 system to a 2.4 system
    if os.path.exists(backup_skel_path):
        from_version = version
        to_version = version
        if not version_exists(version):
            to_version = OMD_VERSION
            sys.stdout.write("\nUpdating site %s from %s to version %s...\n" % (g_sitename, from_version, to_version))

            putenv("OMD_UPDATE_FROM_VERSION", from_version)
            putenv("OMD_UPDATE_TO_VERSION", to_version)
            putenv("OMD_UPDATE_BASE", g_sitedir)
            if not call_scripts('pre-update', prefix=("/omd/versions/%s" % to_version)):
                sys.stdout.write("update canceled by pre-update script\n\n")
                sys.exit(1)

        # read permissions
        read_skel_permissions()
        old_perms = load_skel_permissions_for_path(backup_skel_path+'/skel.permissions')

        from_skelroot = backup_skel_path+'/skel'
        to_skelroot = "/omd/versions/%s/skel" % to_version

        # First walk through skeleton files of new version
        walk_skel(to_skelroot, update_file, (from_version, to_version, g_sitedir, old_perms, from_skelroot), {}, depth_first=False)

        # Now handle files present in old but not in new skel files
        walk_skel(from_skelroot, update_file, (from_version, to_version, g_sitedir, old_perms, from_skelroot), {}, depth_first=True, exclude_if_in = to_skelroot)

        # Change symbolic link pointing to new version
        create_version_symlink(g_sitename, to_version)

        if am_root:
            chown_tree(g_sitedir, g_sitename)

        # Let hooks do their work and update configuration.
        load_site_conf()
        create_config_environment()
        config_set_all()

        # Entry for tmps in /etc/fstab
        if not reuse:
            add_to_fstab(g_sitename, tmpfs_size = options.tmpfs_size)

        if from_version != to_version:
            call_scripts('post-update')

        sys.stdout.write('Finished update to version %s.\n' % OMD_VERSION)

    if os.path.exists(backup_skel_path):
        shutil.rmtree(backup_skel_path)

    # Now switch over to the new site as currently active site
    os.chdir(g_sitedir)
    set_environment()

    # Entry for tmps in /etc/fstab
    if not reuse:
        add_to_fstab(g_sitename, tmpfs_size = options.tmpfs_size)

    # give new user all files
    if am_root:
        chown_tree(g_sitedir, g_sitename)

    finalize_site("restore", options.apache_reload)

    if not am_root:
        sys.stdout.write("Restore completed as site user. "
                         "You may have to manually restart Apache...\n")


def kill_site_user_processes(site, exclude_current_and_parents=False):
    import signal
    pids = site_user_processes(site, exclude_current_and_parents)
    tries = 5
    while tries > 0 and pids:
        for pid in pids[:]:
            try:
                if opt_verbose:
                    sys.stdout.write("Killing process %d...\n" % pid)
                os.kill(pid, signal.SIGKILL)
            except OSError as e:
                if e.errno == 3:
                    pids.remove(pid)  # No such process
                else:
                    raise
        time.sleep(1)
        tries -= 1

    if pids:
        bail_out(tty_error + ": Failed to kill site processes: %s" % ", ".join(map(str, pids)))


def get_current_and_parent_pids():
    """Return list of PIDs of the current process and parent process tree till pid 0"""
    pids = []
    process = psutil.Process()
    while process and process.pid != 0:
        pids.append(process.pid)
        process = process.parent()
    return pids


def site_user_processes(site, exclude_current_and_parents):
    """Return list of PIDs of all running site user processes (that are not excluded)"""
    exclude = []
    if exclude_current_and_parents:
        exclude = get_current_and_parent_pids()

    p = subprocess.Popen(["ps", "-U", site.name, "-o", "pid", "--no-headers"],
                         close_fds=True,
                         stdin=open(os.devnull),
                         stdout=subprocess.PIPE)
    exclude.append(p.pid)

    pids = []
    for l in p.communicate()[0].split("\n"):
        line = l.strip()
        if not line:
            continue

        pid = int(line)

        if pid in exclude:
            continue

        pids.append(pid)
    return pids


def main_cleanup(args, options=None):
    package_manager = PackageManager.factory()
    if package_manager is None:
        bail_out(tty_error + ": Command is not supported on this platform")

    for version in omd_versions():
        site_ids = [ s for s in all_sites() if site_version(s) == version ]
        if site_ids:
            sys.stdout.write("%s%-20s%s In use (by %s). Keeping this version.\n" %
                    (tty_bold, version, tty_normal, ", ".join(site_ids)))
            continue
        if version == OMD_VERSION and not opt_force:
            sys.stdout.write("%s%-20s%s Default version. Keeping this version unless using --force.\n" %
                    (tty_bold, version, tty_normal))
            continue

        version_path = os.path.join("/omd/versions", version)

        packages = package_manager.find_packages_of_path(version_path)
        omdpackages = list(filter(lambda pkg: b"-addons" not in pkg, packages))
        addonpackages = list(filter(lambda pkg: b"-addons" in pkg, packages))
        if len(omdpackages) != 1:
            sys.stdout.write("%s%-35s%s Could not determine package. Keeping this version.\n" %
                    (tty_bold, version, tty_normal))
            continue

        for pkg in addonpackages:
            sys.stdout.write("%s%-35s%s Uninstalling\n" % (tty_bold, str(pkg), tty_normal))
            package_manager.uninstall(pkg)

        sys.stdout.write("%s%-35s%s Uninstalling\n" % (tty_bold, version, tty_normal))
        package_manager.uninstall(omdpackages[0])

        # In case there were modifications made to the version the uninstall may leave
        # some files behind. Remove the whole version directory
        if os.path.exists(version_path):
            shutil.rmtree(version_path)


    # In case the last version has been removed ensure some things created globally
    # are removed.
    if not omd_versions():
        _cleanup_global_files()


def _cleanup_global_files():
    sys.stdout.write("No version left. Cleaning up global files.\n")
    shutil.rmtree(g_info["OMD_PHYSICAL_BASE"], ignore_errors=True)

    for path in [
            "/omd",
            g_info["APACHE_CONF_DIR"] + "/zzz_omd.conf",
            "/etc/init.d/omd",
            "/usr/bin/omd",
        ]:
        try:
            os.unlink(path)
        except OSError as e:
            if e.errno == 2:
                pass
            else:
                raise

    if group_exists("omd"):
        groupdel("omd")



class PackageManager(metaclass=abc.ABCMeta):
    @classmethod
    def factory(self):
        distro_code = g_info["DISTRO_CODE"]
        if distro_code.startswith("el") \
           or distro_code.startswith("fc") \
           or distro_code.startswith("sles"):
            cls = PackageManagerRPM
        else:
            cls = PackageManagerDEB

        return cls()


    @abc.abstractmethod
    def uninstall(self, cmd):
        p = self._execute(cmd)
        output = p.communicate()[0]
        if p.wait() != 0:
            bail_out(tty_error + ": Failed to uninstall package: %s" % output.decode("utf-8").strip())


    def _execute(self, cmd):
        if opt_verbose:
            sys.stdout.write("Executing: %s\n" % subprocess.list2cmdline(cmd))

        return subprocess.Popen(cmd, shell=False, close_fds=True,
                stdin=open(os.devnull), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)



class PackageManagerDEB(PackageManager):
    def uninstall(self, package_name):
        return super(PackageManagerDEB, self).uninstall(
            ["apt-get", "-y", "purge", package_name])


    def find_packages_of_path(self, path):
        real_path = os.path.realpath(path)

        p = self._execute(["dpkg", "-S", real_path])
        output = p.communicate()[0]
        if p.wait() != 0:
            bail_out(tty_error + ": Failed to find packages: %s" % output.decode("utf-8").strip())

        for line in output.split(b"\n"):
            if line.endswith(b": %s" % real_path.encode("UTF-8")):
                return line.split(b": ", 1)[0].split(b", ")

        return []



class PackageManagerRPM(PackageManager):
    def uninstall(self, package_name):
        return super(PackageManagerRPM, self).uninstall(
            ["rpm", "-e", package_name])


    def find_packages_of_path(self, path):
        real_path = os.path.realpath(path)

        p = self._execute(["rpm", "-qf", real_path])
        output = p.communicate()[0]

        if p.wait() == 1 and "not owned" in output:
            return []

        elif p.wait() != 0:
            bail_out(tty_error + ": Failed to find packages: %s" % output.decode("utf-8").strip())

        return output.strip().split(b"\n")


exclude_options = [
    ( "--no-rrds", None,  { "help":"do not copy RRD files (performance data", "action":"count", "default":0 } ),
    ( "--no-dbs",  None,  { "help":"do not copy database data (mysql, influxdb, victoriametrics)", "action":"count", "default":0 } ),
    ( "--no-logs", None,  { "help":"do not copy log files", "action":"count", "default":0 } ),
    ( "--no-past", "-N",  { "help":"do not copy RRD file and log files", "action":"count", "default":0 } ),
    ( "--no-tmp",  None,  { "help":"do not copy tmp files", "action":"count", "default":0 } ),
    ( "--exclude", None,  { "help":"do not copy given exclude path. Can be used multiple times. Ex.: --exclude=local/*", "action":"append" }),
]

status_options = [
    ( "--version",  "-V",  { "help":"only affect services having version ARG" }),
    ( "--auto",  None,  { "help":"show only sites with AUTOSTART = on", "action":"count", "default":0 }),
    ( "--bare", "-b", { "help":"output plain text optimized for parsing", "action":"count", "default":0 } ),
    ( "--parallel", "-p",  { "help":"Invoke action of sites in parallel", "action":"count", "default":0 }),
]

class Command(typing.NamedTuple):
    command:      str               # The id of the command
    description:  str               # Text for the help of omd
    fn:           any               # Handler function for this command
    only_root:    bool = False      # This option is only available when omd command is run as root
    no_suid:      bool = False      # The command is available for root and site-user, but no switch to the site user is performed before execution the mode function
    needs_site:   int  = False      # When run as root: 0: no site must be specified, 1: site must be specified, 2: site is optional
    must_exist:   bool = False      # Site must exist for this command
    confirm:      str  = ""         # Is a confirm dialog shown before command execution?
    args:         str  = ""         # Help text for command individual arguments
    option_spec:  any  = []         # List of individual arguments for this command (passed to argparse.add_argument)
    confirm_text: str  = ""         # Confirm text to show before calling the handler function
    more_help:    any  = None       # Callback to print detailed help

commands = [
  Command(
    command     = "help",
    description = "Show general help",
    fn          = main_help,
  ),

  Command(
    command     = "setversion",
    description = "Sets the default version of OMD which will be used by new sites",
    fn          =  main_setversion,
    only_root   =  True,
    args        = "VERSION",
  ),

  Command(
    command     = "version",
    description = "Show version of OMD",
    fn          = main_version,
    args        = "[SITE]",
    option_spec = [
        ("--bare", "-b", { "help":"output plain text optimized for parsing", "action":"count", "default":0 } )
    ],
  ),

  Command(
    command     = "versions",
    description = "List installed OMD versions",
    fn          =  main_versions,
    option_spec = [
        ("--bare", "-b", { "help":"output plain text optimized for parsing", "action":"count", "default":0 } )
    ],
  ),

  Command(
    command     = "sites",
    description = "Show list of sites",
    fn          =  main_sites,
    option_spec = [
        ("--bare", "-b", { "help":"output plain text optimized for parsing", "action":"count", "default":0 } )
    ],
  ),

  Command(
    command     = "create",
    description = "Create a new site",
    fn          = main_create,
    only_root   = True,
    needs_site  = 1,
    option_spec = [
        ( "--uid",           "-u",   { "help":"create site user with UID ARG" } ),
        ( "--gid",           "-g",   { "help":"create site group with GID ARG"} ),
        ( "--admin-password", None,  { "help":"set initial password instead of generating one"} ),
        ( "--reuse",          None,  { "help":"do not create a site user, reuse existing one", "action":"count", "default":0 } ),
        ( "--no-init",       "-n",   { "help":"leave new site directory empty (a later omd init does this", "action":"count", "default":0 }),
        ( "--no-autostart",  "-A",   { "help":"set AUTOSTART to off (useful for test sites)", "action":"count", "default":0 }),
        ( "--apache-reload",  None,  { "help":"Issue a reload of the system apache instead of a restart", "action":"count", "default":0 }),
        ( "--no-tmpfs",       None,  { "help":"set TMPFS to off", "action":"count", "default":0 }),
        ( "--tmpfs-size",    "-t",   { "help":"specify the maximum size of the tmpfs (defaults to 50% of RAM), examples: 500M, 20G, 60%"} ),
    ],
    confirm_text =
        "This command performs the following actions on your system:\n"
        "- Create the system user <SITENAME>\n"
        "- Create the system group <SITENAME>\n"
        "- Create and populate the site home directory\n"
        "- Restart the system wide apache daemon\n"
        "- Add tmpfs for the site to fstab and mount it"
  ),

  Command(
    command     = "init",
    description = "Populate site directory with default files and enable the site",
    fn          = main_init,
    only_root   = True,
    needs_site  = 1,
    must_exist  = True,
    option_spec = [
      ( "--apache-reload", None, { "help":"Issue a reload of the system apache instead of a restart", "action":"count", "default":0 }),
    ],
  ),

  Command(
    command     = "rm",
    description = "Remove a site (and its data)",
    fn          = main_rm,
    no_suid     = True,
    only_root   = True,
    needs_site  = 1,
    must_exist  = True,
    option_spec = [
      ( "--reuse",         None, { "help":"assume --reuse on create, do not delete site user/group", "action":"count", "default":0 }),
      ( "--kill",          None, { "help":"kill processes of the site before deleting it", "action":"count", "default":0 }),
      ( "--apache-reload", None, { "help":"Issue a reload of the system apache instead of a restart", "action":"count", "default":0 }),
    ],
    confirm      = True,
    confirm_text =
        "PLEASE NOTE: This action removes all configuration files\n"
        "             and variable data of the site.\n"
        "\n"
        "In detail the following steps will be done:\n"
        "- Stop all processes of the site\n"
        "- Unmount tmpfs of the site\n"
        "- Remove tmpfs of the site from fstab\n"
        "- Remove the system user <SITENAME>\n"
        "- Remove the system group <SITENAME>\n"
        "- Remove the site home directory\n"
        "- Restart the system wide apache daemon\n"
  ),

  Command(
    command     = "disable",
    description = "Disable a site (stop it, unmount tmpfs, remove Apache hook)",
    fn          = main_disable,
    only_root   = True,
    needs_site  = 1,
    must_exist  = True,
    option_spec = [
        ( "--kill", None, { "help":"kill processes using tmpfs before unmounting it", "action":"count", "default":0 }),
    ]
  ),

  Command(
    command     = "enable",
    description = "Enable a site (reenable a formerly disabled site)",
    fn          = main_enable,
    only_root   = True,
    needs_site  = 1,
    must_exist  = True,
    option_spec = [
        ( "--apache-reload", None, { "help":"Issue a reload of the system apache instead of a restart", "action":"count", "default":0 }),
    ],
  ),

  Command(
    command     = "mv",
    description = "Rename a site",
    fn          = lambda args, opts: main_mv_or_cp("mv", args, opts),
    only_root   = True,
    needs_site  = 1,
    must_exist  = True,
    args        = "NEWNAME",
    option_spec = [
        ( "--uid",           "-u",   { "help":"create site user with UID ARG" } ),
        ( "--gid",           "-g",   { "help":"create site group with GID ARG"} ),
        ( "--reuse",          None,  { "help":"do not create a site user, reuse existing one", "action":"count", "default":0 } ),
        ] + exclude_options + [
        ( "--conflict",       None,  { "help":"non-interactive conflict resolution. ARG is install, keepold, abort or ask"}),
        ( "--apache-reload",  None,  { "help":"Issue a reload of the system apache instead of a restart", "action":"count", "default":0 }),
        ( "--tmpfs-size",    "-t",   { "help":"specify the maximum size of the tmpfs (defaults to 50% of RAM), examples: 500M, 20G, 60%"} ),
        ( "--kill", None, { "help":"kill processes using tmpfs before unmounting it", "action":"count", "default":0 }),
    ],
  ),

  Command(
    command     = "cp",
    description = "Make a copy of a site",
    fn          = lambda args, opts: main_mv_or_cp("cp", args, opts),
    only_root   = True,
    needs_site  = 1,
    must_exist  = True,
    args        = "NEWNAME",
    option_spec = [
        ( "--uid",           "-u",   { "help":"create site user with UID ARG" } ),
        ( "--gid",           "-g",   { "help":"create site group with GID ARG"} ),
        ( "--reuse",          None,  { "help":"do not create a site user, reuse existing one", "action":"count", "default":0 } ),
        ] + exclude_options + [
        ( "--conflict",       None,  { "help":"non-interactive conflict resolution. ARG is install, keepold, abort or ask"}),
        ( "--apache-reload",  None,  { "help":"Issue a reload of the system apache instead of a restart", "action":"count", "default":0 }),
        ( "--tmpfs-size",    "-t",   { "help":"specify the maximum size of the tmpfs (defaults to 50% of RAM), examples: 500M, 20G, 60%"} ),
        ( "--kill", None, { "help":"kill processes using tmpfs before unmounting it", "action":"count", "default":0 }),
    ],
  ),

  Command(
    command     = "update",
    description = "Update site to other version of OMD",
    fn          = main_update,
    needs_site  = 1,
    must_exist  = True,
    option_spec = [
        ( "--conflict", None,  { "help":"non-interactive conflict resolution. ARG is install, keepold, abort or ask"}),
        ( "--dry-run", "-n",   { "help":"do not update, but list upcoming changes and potential conflicts.", "action": "count", "default": 0 }),
    ],
  ),

  Command(
    command     = "start",
    description = "Start services of one or all sites",
    fn          = lambda args, opts: main_init_action("start", args, opts),
    needs_site  = 2,
    must_exist  = True,
    args        = "[SERVICE]",
    option_spec = status_options,
  ),

  Command(
    command     = "stop",
    description = "Stop services of one or all sites",
    fn          = lambda args, opts: main_init_action("stop", args, opts),
    needs_site  = 2,
    must_exist  = True,
    args        = "[SERVICE]",
    option_spec = status_options,
  ),

  Command(
    command     = "restart",
    description = "Restart services of one or all sites",
    fn          = lambda args, opts: main_init_action("restart", args, opts),
    needs_site  = 2,
    must_exist  = True,
    args        = "[SERVICE]",
    option_spec = status_options,
  ),

  Command(
    command     = "reload",
    description = "Reload services of one or all sites",
    fn          = lambda args, opts: main_init_action("reload", args, opts),
    needs_site  = 2,
    must_exist  = True,
    args        = "[SERVICE]",
    option_spec = status_options,
  ),

  Command(
    command     = "status",
    description = "Show status for services on one or all sites",
    fn          = lambda args, opts: main_init_action("status", args, opts),
    needs_site  = 2,
    must_exist  = True,
    args        = "[SERVICE]",
    option_spec = status_options,
  ),

  Command(
    command     = "check",
    description = "Do config check for services on one or all sites",
    fn          = lambda args, opts: main_init_action("check", args, opts),
    needs_site  = 2,
    must_exist  = True,
    args        = "[SERVICE]",
    option_spec = status_options,
  ),

  Command(
    command     = "config",
    description = "Show and set site configuration parameters",
    fn          = main_config,
    needs_site  = 1,
    must_exist  = True,
    args        = "...",
    more_help   = config_usage,
  ),

  Command(
    command     = "diff",
    description = "Shows differences compared to the original version files. Will exit 1 if there ther had been changes.",
    fn          = main_diff,
    needs_site  = 1,
    must_exist  = True,
    args        = "([RELBASE])",
    option_spec = [
        ( "--bare", "-b", { "help":"output plain diff format, no beautifying", "action":"count", "default":0 } ),
    ],
  ),

  Command(
    command     = "vimdiff",
    description = "Opens vimdiff with the current file and the default version of that file",
    fn          = main_vimdiff,
    needs_site  = 1,
    must_exist  = True,
    args        = "([RELBASE])",
  ),

  Command(
    command     = "reset",
    description = "Reset file to default version from skeleton",
    fn          = main_reset,
    needs_site  = 1,
    must_exist  = True,
    args        = "([RELBASE])",
  ),

  Command(
    command     = "su",
    description = "Run a shell as a site-user",
    fn          = main_su,
    only_root   = True,
    needs_site  = 1,
    must_exist  = True,
  ),

  Command(
    command     = "mount",
    description = "Mount ramdisk volumes of site(s) and populate tmp/",
    fn          = main_mount,
    needs_site  = 2,
    must_exist  = True,
    option_spec = [
        ( "--version",  "-V",  { "help":"nmount only sites with version ARG" }),
    ],
  ),

  Command(
    command     = "umount",
    description = "Umount ramdisk volumes of site(s)",
    fn          = main_umount,
    needs_site  = 2,
    must_exist  = True,
    option_spec = [
        ( "--version",  "-V",  { "help":"unmount only sites with version ARG" }),
        ( "--kill",      None, { "help":"kill processes using the tmpfs before unmounting it", "action":"count", "default":0 }),
    ],
  ),

  Command(
    command     = "backup",
    description = "Create a backup tarball of a site, writing it to a file",
    fn          = main_backup,
    no_suid     = True,
    needs_site  = 1,
    must_exist  = True,
    args        = "[-|ARCHIVE_PATH]",
    option_spec = [
        ( "--kill",      None, { "help":"kill processes using the tmpfs before unmounting it", "action":"count", "default":0 }),
    ] + exclude_options,
  ),

  Command(
    command     = "restore",
    description = "Restores the backup of a site to an existing site or creates a new site",
    fn          = main_restore,
    no_suid     = True,
    args        = "[SITE] [-|ARCHIVE_PATH]",
    option_spec = [
        ( "--uid",           "-u",  { "help":"create site user with UID ARG" } ),
        ( "--gid",           "-g",  { "help":"create site group with GID ARG"} ),
        ( "--reuse",          None, { "help":"do not create a site user, reuse existing one", "action":"count", "default":0 } ),
        ( "--kill",           None, { "help":"kill processes of site when reusing an existing one before restoring", "action":"count", "default":0 }),
        ( "--apache-reload",  None, { "help":"Issue a reload of the system apache instead of a restart", "action":"count", "default":0 }),
        ( "--conflict",       None, { "help":"non-interactive conflict resolution. ARG is install, keepold, abort or ask"}),
        ( "--tmpfs-size",    "-t",  { "help":"specify the maximum size of the tmpfs (defaults to 50% of RAM), examples: 500M, 20G, 60%"} ),
    ],
  ),

  Command(
    command     = "cleanup",
    description = "Uninstall all other OMD versions that are not used by any site.",
    only_root   = True,
    fn          = main_cleanup,
  ),

  Command(
    command     = "diag",
    description = "Show diagnosis information",
    args        = "[MODE]",
    must_exist  = True,
    fn          = main_diag,
  ),
]

def print_command_help(cmd_spec):
    # Give a short overview over the command specific options
    # when the user specifies --help:
    sys.stdout.write("Usage: omd %s %s%s[options...]\n" % (command, cmd_spec.needs_site and "[SITE] " or "", cmd_spec.args and cmd_spec.args+" " or ""))
    sys.stdout.write("\nDescription: %s\n\n" % cmd_spec.description)
    if cmd_spec.more_help:
        cmd_spec.more_help()
    sys.stdout.write("Options for the '%s' command:\n" % command)
    for spec in cmd_spec.option_spec:
        args_text = "%s%s" % (spec[1] and  spec[1]+"," or "", spec[0])
        need_arg = True
        if "action" in spec[2] and spec[2]["action"] == "count":
            need_arg = False
        sys.stdout.write(" %-26s %3s  %s\n" %(args_text, need_arg and "ARG" or "", spec[2]["help"]))
    if len(cmd_spec.option_spec) == 0:
        sys.stdout.write("  no specific options for this command.\n")


def exec_other_omd(version):
    # Rerun with omd of other version
    omd_path = "/omd/versions/%s/bin/omd" % version
    if os.path.exists(omd_path):
        os.execv(omd_path, sys.argv)
        bail_out(tty_error + ": Cannot run bin/omd of version %s." % version)
    else:
        bail_out(tty_error + ": Site %s uses version %s which is not installed.\n"
                "Please reinstall that version and retry this command.\n"
                "Or use the --force option to run the command with this version." %
                (g_sitename, version))


def omd_version_exists(version):
    omd_path = "/omd/versions/%s/bin/omd" % version
    if os.path.exists(omd_path):
        return True
    return False

def version_numeric(version):
    num = re.findall(r'^(\d+\.\d+)', version)
    try:
        return(float(num[0]))
    except Exception:
        return(0)

def random_password():
    import random
    return ''.join(random.choice(string.ascii_letters + string.digits) for i in range(8))

# returns true if this is the root user
def am_root():
    am_root = os.getuid() == 0
    return am_root

# fork and run handler in site context, returns true if successful
def call_as_forked_site_user(handler, args, kwargs):
    pid = os.fork()

    if pid == 0:
        # this is the child process
        switch_to_site_user()
        set_environment()
        if handler(*args, **kwargs):
            sys.exit(0)
        sys.exit(1)

    # this is the parent process
    wpid, status = os.waitpid(pid, 0)

    return status == 0

# exits with a stack trace if this is the root
def bail_out_if_root(msg):
    if am_root():
        print_stack_error(msg)
        sys.exit(3)

def print_stack_error(msg):
    import traceback
    traceback.print_stack(file=sys.stderr)
    sys.stderr.write(tty_error +" "+msg)

def print_usage():
    argparser.print_usage()
    sys.stdout.write("Use -h/--help to see the full description of all options and available commands. Or use 'omd help <command>' to see help for a specific command.\n")

#.
#   .--Main----------------------------------------------------------------.
#   |                        __  __       _                                |
#   |                       |  \/  | __ _(_)_ __                           |
#   |                       | |\/| |/ _` | | '_ \                          |
#   |                       | |  | | (_| | | | | |                         |
#   |                       |_|  |_|\__,_|_|_| |_|                         |
#   |                                                                      |
#   +----------------------------------------------------------------------+
#   |  Main entry point                                                    |
#   '----------------------------------------------------------------------'

# parse -V/--version without value and simply print out the version
for i in range(len(sys.argv)):
    o = sys.argv[i]
    if o == '-V' or o == "--version":
        if i == len(sys.argv)-1 or sys.argv[i+1].startswith("-"):
            sys.argv[i] = "version"

# Handle global options.
argparser = argparse.ArgumentParser(add_help=False, conflict_handler='resolve')
argparser.add_argument('command', nargs='?')
argparser.add_argument('-V', '--version')
argparser.add_argument('-v', '--verbose',     action="count", default=0)
argparser.add_argument('-f', '--force',       action="count", default=0)
argparser.add_argument('-i', '--interactive', action="count", default=0)
argparser.add_argument('-h', '--help',        action="count", default=0)
args, main_args = argparser.parse_known_args(sys.argv[1:])

command     = args.command
opt_version = args.version

# switch to other version (except update/restore which switch later)
if args.version != None and args.version != OMD_VERSION and command != "update" and command != "restore":
    exec_other_omd(args.version)

if not command:
    main_help()
    sys.exit(1)

if command == "help":
    opt_help = True
    if len(main_args) > 0:
        command = main_args[0]
        main_args = main_args[1:]
    else:
        main_help()
        sys.exit(1)

found = False
for cmd_spec in commands:
    if cmd_spec.command == command:
        found = True
        break

if not found:
    sys.stderr.write(tty_error +": no such command: %s\n" % command)
    print_usage()
    sys.exit(1)

if os.getuid() != 0 and cmd_spec.only_root:
    bail_out(tty_error + ": omd: root permissions are needed for this command.")

# Parse command options. Parse again all options with additional arguments
for spec in cmd_spec.option_spec:
    if spec[1]:
        argparser.add_argument(spec[0], spec[1], **spec[2])
    else:
        argparser.add_argument(spec[0], **spec[2])

args, main_args = argparser.parse_known_args(sys.argv[1:])
opt_verbose     = args.verbose     >= 1
opt_force       = args.force       >= 1
opt_interactive = args.interactive >= 1
opt_help        = args.help        >= 1 or opt_help

# check if there are any arguments left?
for arg in main_args:
    if arg.startswith("-"):
        bail_out(tty_error + ": Invalid option %s.\n"
            "Call omd help for available options." % arg)

if opt_help:
    print_command_help(cmd_spec)
    print_general_options()
    sys.exit(1)

# Some commands need a site to be specified. If we are
# called as root, this must be done explicitely. If we
# are site user, the site name is our user name
g_sitename = None
if cmd_spec.needs_site > 0:
    if os.getuid() != 0:
        g_sitename = site_name()

    if g_sitename == None and len(main_args) >= 1:
        g_sitename = main_args[0]
        main_args = main_args[1:]

if cmd_spec.needs_site == 1 and g_sitename == None:
    bail_out(tty_error + ": omd: please specify site.")
check_site_user(cmd_spec.must_exist)

# Commands operating on an existing site *must* run omd in
# the same version as the site has! Sole exception: update.
# That command must be run in the target version
if g_sitename and not args.version and cmd_spec.must_exist and command != "update" and command != "restore":
    v = site_version(g_sitename)
    if v is None: # Site has no homedirectory
        if command == "rm":
            sys.stdout.write("WARNING: This site has an empty home directory and is not\n"
                             "assigned to any OMD version. You are running version %s.\n" % OMD_VERSION)
        elif command != "init":
            bail_out(tty_error + ": This site has an empty home directory /omd/sites/%s.\n"
                     "If you have created that site with 'omd create --no-init %s'\n"
                     "then please first do an 'omd init %s'." % (3*(g_sitename,)))
    elif OMD_VERSION != v:
        if omd_version_exists(v) and not opt_force:
            exec_other_omd(v)

read_info()

if g_sitename:
    set_site_globals()

# Commands which affect a site and can be called as root *or* as
# site user should always run with site user priviledges. That way
# we are sure that new files and processes are created under the
# site user and never as root.
g_orig_wd = os.getcwd()
if not cmd_spec.no_suid and g_sitename and os.getuid() == 0 and not cmd_spec.only_root:
    switch_to_site_user()

    # strip off sitename from arguments, it would end of as additional argument after changing omd version, ex.: on update
    found_command = False
    for a in sys.argv:
        if not found_command and a == command:
            found_command = True
            continue
        if found_command and a == g_sitename:
            sys.argv.remove(a)
            break

# Make sure environment is in a defined state
if g_sitename and command != "rm":
    clear_environment()
    set_environment()

if (opt_interactive or cmd_spec.confirm) and not opt_force:
    sys.stdout.write("%s (yes/NO): " % cmd_spec.confirm_text)
    sys.stdout.flush()
    a = sys.stdin.readline().strip()
    if a.lower() != "yes":
        sys.stdout.write(tty_red + tty_bold + "canceled " + tty_normal + " \n")
        sys.exit(0)

try:
    cmd_spec.fn(main_args, args)
except KeyboardInterrupt:
    bail_out(tty_normal + "Aborted.")
