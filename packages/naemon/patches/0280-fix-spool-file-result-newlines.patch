From 37f166ae2ebc21962b3874260eed5dc4438263f4 Mon Sep 17 00:00:00 2001
From: Sven Nierlein <sven@nierlein.de>
Date: Sat, 19 Jan 2019 20:38:26 +0100
Subject: [PATCH] fix newline handling in spoolfile results

- newlines from spoolfiles need to be unescaped, otherwise they remain
  as \\n in the plugin output und multiline output parser does not
  parse the output correctly.

- instead of adding more and more exceptions to g_strescape, we really only
  want to escape newlines, so do just that. Otherwise we end up with double
  encoded escape sequences in the long plugin output.

Signed-off-by: Sven Nierlein <sven@nierlein.de>
---
 src/naemon/checks.c                  |  4 +-
 src/naemon/utils.c                   | 72 ++++++++++++++++++++++++
 src/naemon/utils.h                   |  3 +
 tests/test-check-result-processing.c | 83 ++++++++++++++++++++++++++++
 tests/test-checks.c                  | 12 ++++
 5 files changed, 172 insertions(+), 2 deletions(-)

diff --git a/src/naemon/checks.c b/src/naemon/checks.c
index a975feb9..3eed6d4d 100644
--- a/src/naemon/checks.c
+++ b/src/naemon/checks.c
@@ -188,7 +188,7 @@ int parse_check_output(char *buf, char **short_output, char **long_output, char
 	*short_output = check_output->short_output;
 	*perf_data = check_output->perf_data;
 	if(escape_newlines_please == TRUE && check_output->long_output != NULL) {
-		*long_output = g_strescape(check_output->long_output, "\",\\n");
+		*long_output = escape_plugin_output(check_output->long_output);
 		free(check_output->long_output);
 	} else {
 		*long_output = check_output->long_output;
@@ -462,7 +462,7 @@ int process_check_result_file(char *fname)
 			else if (!strcmp(var, "return_code"))
 				cr.return_code = atoi(val);
 			else if (!strcmp(var, "output"))
-				cr.output = nm_strdup(val);
+				cr.output = unescape_plugin_output(val);
 		}
 	}
 
diff --git a/src/naemon/utils.c b/src/naemon/utils.c
index 791f3380..ddb7c74c 100644
--- a/src/naemon/utils.c
+++ b/src/naemon/utils.c
@@ -1191,3 +1191,75 @@ int reset_variables(void)
 
 	return OK;
 }
+
+/******************************************************************/
+/************************* ESCAPE FUNCTIONS *************************/
+/******************************************************************/
+
+/* escapes newlines in a string. */
+char *escape_plugin_output(const char *rawbuf) {
+	char *newbuf = NULL;
+	int x;
+	int y;
+
+	if (rawbuf == NULL)
+		return NULL;
+
+	/* count the escapes we need to make. */
+	for (x = 0, y = 0; rawbuf[x]; x++) {
+		if (rawbuf[x] == '\n')
+			y++;
+	}
+
+	if (y == 0)
+		return strdup(rawbuf);
+
+	if ((newbuf = malloc(x + y + 1)) == NULL)
+		return NULL;
+
+	for (x = 0, y = 0; rawbuf[x]; x++) {
+		if (rawbuf[x] == '\n') {
+			newbuf[y++] = '\\';
+			newbuf[y++] = 'n';
+		}
+		else
+			newbuf[y++] = rawbuf[x];
+	}
+	newbuf[y] = '\0';
+
+	return newbuf;
+}
+
+/* unescapes newlines in a string. */
+char *unescape_plugin_output(const char *rawbuf) {
+	char *newbuf = NULL;
+	int x;
+	int y;
+
+	if (rawbuf == NULL)
+		return NULL;
+
+	/* count the replacements we need to make. */
+	for (x = 0, y = 0; rawbuf[x]; x++) {
+		if (rawbuf[x] == '\\' && rawbuf[x + 1] == 'n')
+			x++, y++;
+	}
+
+	if (y == 0)
+		return nm_strdup(rawbuf);
+
+	if ((newbuf = nm_malloc(x - y + 1)) == NULL)
+		return NULL;
+
+	for (x = 0, y = 0; rawbuf[x]; x++) {
+		if (rawbuf[x] == '\\' && rawbuf[x + 1] == 'n') {
+			x++;
+			newbuf[y++] = '\n';
+		}
+		else
+			newbuf[y++] = rawbuf[x];
+	}
+	newbuf[y] = '\0';
+
+	return newbuf;
+}
diff --git a/src/naemon/utils.h b/src/naemon/utils.h
index b973c530..f7106a8b 100644
--- a/src/naemon/utils.h
+++ b/src/naemon/utils.h
@@ -55,6 +55,9 @@ const char *get_program_version(void);
 
 void cleanup(void);                                  	/* cleanup after ourselves (before quitting or restarting) */
 
+char *escape_plugin_output(const char *);
+char *unescape_plugin_output(const char *);
+
 NAGIOS_END_DECL
 
 #endif
diff --git a/tests/test-check-result-processing.c b/tests/test-check-result-processing.c
index 5302a474..7c05b69b 100644
--- a/tests/test-check-result-processing.c
+++ b/tests/test-check-result-processing.c
@@ -4,6 +4,45 @@
 #include "naemon/checks_service.h"
 #include "naemon/globals.h"
 #include "naemon/logging.h"
+#include "naemon/events.h"
+
+#define TARGET_SERVICE_NAME "my_service"
+#define TARGET_HOST_NAME "my_host"
+
+static host *hst;
+static service *svc;
+static command *cmd;
+void setup (void) {
+
+	init_event_queue();
+	init_objects_host(1);
+	init_objects_service(1);
+	init_objects_command(1);
+
+	cmd = create_command("my_command", "/bin/true");
+	ck_assert(cmd != NULL);
+	register_command(cmd);
+
+	hst = create_host(TARGET_HOST_NAME);
+	ck_assert(hst != NULL);
+	hst->check_command_ptr = cmd;
+	hst->check_command = nm_strdup("something or other");
+	register_host(hst);
+
+	svc = create_service(hst, TARGET_SERVICE_NAME);
+	ck_assert(svc != NULL);
+	svc->check_command_ptr = cmd;
+	svc->accept_passive_checks = TRUE;
+	register_service(svc);
+
+}
+
+void teardown (void) {
+	destroy_event_queue();
+	destroy_objects_command();
+	destroy_objects_service();
+	destroy_objects_host();
+}
 
 START_TEST(host_soft_to_hard)
 {
@@ -29,12 +68,55 @@ START_TEST(host_soft_to_hard)
 }
 END_TEST
 
+START_TEST(spool_file_processing)
+{
+	int result;
+	FILE *fp;
+	char test_spool_file[] = "/tmp/naemon-spool-test-XXXXXX";
+	int fd;
+	time_t now = time(NULL);
+
+	fd = mkstemp(test_spool_file);
+	close(fd);
+	fp = fopen(test_spool_file, "a");
+	fprintf(fp,
+		"file_time=%ld\n"
+		"\n"
+		"host_name=%s\n"
+		"service_description=%s\n"
+		"check_type=1\n"
+		"check_options=0\n"
+		"scheduled_check=0\n"
+		"latency=0.000000\n"
+		"start_time=%ld.000000\n"
+		"finish_time=%ld.000000\n"
+		"early_timeout=0\n"
+		"exited_ok=1\n"
+		"return_code=0\n"
+		"output=testoutput\\nwith multiline\\nand \\backslash|perf=0.001s\n",
+		now,
+		TARGET_HOST_NAME,
+		TARGET_SERVICE_NAME,
+		now,
+		now
+	);
+	fclose(fp);
+	result = process_check_result_file(test_spool_file);
+	ck_assert(result == OK);
+	ck_assert_str_eq(svc->plugin_output, "testoutput");
+	ck_assert_str_eq(svc->long_plugin_output, "with multiline\\nand \\backslash");
+	ck_assert_str_eq(svc->perf_data, "perf=0.001s");
+	unlink(test_spool_file);
+}
+END_TEST
+
 int main(int argc, char **argv)
 {
 	int number_failed = 0;
 	Suite *s;
 	SRunner *sr;
 	TCase *tc_process = tcase_create("Result processing");
+	tcase_add_checked_fixture(tc_process, setup, teardown);
 
 	debug_level = -1;
 	debug_verbosity = 5;
@@ -44,6 +126,7 @@ int main(int argc, char **argv)
 
 	s = suite_create("Check results");
 	tcase_add_test(tc_process, host_soft_to_hard);
+	tcase_add_test(tc_process, spool_file_processing);
 	suite_add_tcase(s, tc_process);
 
 	sr = srunner_create(s);
diff --git a/tests/test-checks.c b/tests/test-checks.c
index 031644ff..1310bd71 100644
--- a/tests/test-checks.c
+++ b/tests/test-checks.c
@@ -189,6 +189,17 @@ START_TEST(multiple_line_output_double_newline_escaping)
 }
 END_TEST
 
+START_TEST(multiline_unicode)
+{
+	full_output = "TEST CRITICAL - testoutput with unicode \342\202\254 on firstline and literal \\backslash\nwith multiline\nand literal \\backslash and some unicode \342\202\254 in the long output.|'unicodeperf\342\202\254'=0.001s\n";
+	output = strdup(full_output);
+	parse_check_output(output, &short_output, &long_output, &perf_data, TRUE, FALSE);
+	ck_assert_str_eq("TEST CRITICAL - testoutput with unicode \342\202\254 on firstline and literal \\backslash", short_output);
+	ck_assert_str_eq("with multiline\\nand literal \\backslash and some unicode \342\202\254 in the long output.", long_output);
+	ck_assert_str_eq("'unicodeperf\342\202\254'=0.001s", perf_data);
+}
+END_TEST
+
 Suite*
 checks_suite(void)
 {
@@ -209,6 +220,7 @@ checks_suite(void)
 	tcase_add_test(tc_output, empty_plugin_output);
 	tcase_add_test(tc_output, multiple_line_output_newline_escaping);
 	tcase_add_test(tc_output, multiple_line_output_double_newline_escaping);
+	tcase_add_test(tc_output, multiline_unicode);
 	suite_add_tcase(s, tc_output);
 	return s;
 }
