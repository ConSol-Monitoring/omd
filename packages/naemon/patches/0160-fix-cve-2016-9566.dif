From 6235cd14bb2047456a8e16c2b95aec43035b688f Mon Sep 17 00:00:00 2001
From: Sven Nierlein <Sven.Nierlein@consol.de>
Date: Wed, 11 Jan 2017 17:09:19 +0100
Subject: [PATCH 1/2] let the systemv init script change uid

a recently discoverd issue showed that you can misuse the daemon_init function
because the logfile is created befor naemon drops the privileges. In order to
remove that code completly we have to start the naemon-core process directly with
the desired user.

Signed-off-by: Sven Nierlein <Sven.Nierlein@consol.de>
---
 daemon-init.in    | 2 +-
 daemon-systemd.in | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/daemon-init.in b/daemon-init.in
index 9a4fcf7..fe1eb44 100644
--- a/daemon-init.in
+++ b/daemon-init.in
@@ -86,7 +86,7 @@ start() {
         start_daemon ${NICE_OPT} -p ${pidfile} -u ${user} $exec -d $config
     elif type start-stop-daemon >/dev/null 2>&1; then
         if [ $NICELEVEL != "0" ]; then NICE_OPT="--nicelevel $NICELEVEL"; fi
-        start-stop-daemon $NICE_OPT --start --user $user --name $prog --pidfile $pidfile --exec $exec -- -d $config
+        start-stop-daemon $NICE_OPT --start --user $user --chuid $user:$group --name $prog --pidfile $pidfile --exec $exec -- -d $config
     else
         daemon --user=$user $exec -d $config
     fi
diff --git a/daemon-systemd.in b/daemon-systemd.in
index ec18922..803c3cb 100644
--- a/daemon-systemd.in
+++ b/daemon-systemd.in
@@ -10,7 +10,7 @@ PIDFile=@lockfile@
 PermissionsStartOnly=true
 ExecStartPre=-/usr/bin/mkdir /var/run/naemon
 ExecStartPre=/usr/bin/chown -R naemon:naemon /var/run/naemon/
-ExecStartPre=@bindir@/naemon -vp @pkgconfdir@/naemon.cfg
+ExecStartPre=su - naemon -c "@bindir@/naemon -vp @pkgconfdir@/naemon.cfg"
 ExecStart=@bindir@/naemon -d @pkgconfdir@/naemon.cfg
 ExecReload=/bin/kill -HUP $MAINPID
 User=naemon

From b9b9147d54427ad334b32a06c45cfbb60b8ab7ab Mon Sep 17 00:00:00 2001
From: Sven Nierlein <Sven.Nierlein@consol.de>
Date: Wed, 11 Jan 2017 17:45:34 +0100
Subject: [PATCH 2/2] add error when started as root

instead of creating (log)files as root and chown them later we simply
should not be started as root at all. This prevents the root exploit
then systemV init scripts start naemon as root user.

Signed-off-by: Sven Nierlein <Sven.Nierlein@consol.de>
---
 src/naemon/logging.c | 18 -----------
 src/naemon/logging.h |  1 -
 src/naemon/naemon.c  | 20 +++---------
 src/naemon/utils.c   | 86 ----------------------------------------------------
 4 files changed, 5 insertions(+), 120 deletions(-)

diff --git a/src/naemon/logging.c b/src/naemon/logging.c
index d3dab7d..f1d93ed 100644
--- a/src/naemon/logging.c
+++ b/src/naemon/logging.c
@@ -175,24 +175,6 @@ static void write_to_all_logs_with_timestamp(char *buffer, unsigned long data_ty
 	write_to_log(buffer, data_type, timestamp);
 }
 
-
-int fix_log_file_owner(uid_t uid, gid_t gid)
-{
-	int r1 = 0, r2 = 0;
-
-	if (!(log_fp = open_log_file()))
-		return -1;
-	r1 = fchown(fileno(log_fp), uid, gid);
-
-	if (open_debug_log() != OK)
-		return -1;
-	if (debug_file_fp)
-		r2 = fchown(fileno(debug_file_fp), uid, gid);
-
-	/* return 0 if both are 0 and otherwise < 0 */
-	return r1 < r2 ? r1 : r2;
-}
-
 int close_log_file(void)
 {
 	if (!log_fp)
diff --git a/src/naemon/logging.h b/src/naemon/logging.h
index 90c8571..4a348f4 100644
--- a/src/naemon/logging.h
+++ b/src/naemon/logging.h
@@ -90,7 +90,6 @@ int write_log_file_info(time_t *); 			/* records log file/version info */
 int open_debug_log(void);
 int close_debug_log(void);
 int close_log_file(void);
-int fix_log_file_owner(uid_t uid, gid_t gid);
 
 /* GLib log handler (GLogFunc*) that maps GLib log messages to their
  * corresponding Naemon levels. Only intended for use as a regular handler,
diff --git a/src/naemon/naemon.c b/src/naemon/naemon.c
index e6d9a17..d08a3e4 100644
--- a/src/naemon/naemon.c
+++ b/src/naemon/naemon.c
@@ -151,6 +151,11 @@ int main(int argc, char **argv)
 #define getopt(argc, argv, o) getopt_long(argc, argv, o, long_options, &option_index)
 #endif
 
+	if (getuid() == 0) {
+		printf("ERROR: do not start naemon as root user.\n");
+		exit(EXIT_FAILURE);
+	}
+
 	/* Make all GLib domain messages go to the usual places. This also maps
 	 * GLib levels to an approximation of their corresponding Naemon levels
 	 * (including debug).
@@ -324,12 +329,6 @@ int main(int argc, char **argv)
 		if (verify_config)
 			printf("   Read main config file okay...\n");
 
-		/* drop privileges */
-		if ((result = drop_privileges(NAEMON_USER, NAEMON_GROUP)) == ERROR) {
-			printf("   Failed to drop privileges.  Aborting.");
-			exit(EXIT_FAILURE);
-		}
-
 		/*
 		 * this must come after dropping privileges, so we make
 		 * sure to test access permissions as the right user.
@@ -457,15 +456,6 @@ int main(int argc, char **argv)
 		nm_free(mac->x[MACRO_PROCESSSTARTTIME]);
 		nm_asprintf(&mac->x[MACRO_PROCESSSTARTTIME], "%lu", (unsigned long)program_start);
 
-		/* drop privileges */
-		if (drop_privileges(NAEMON_USER, NAEMON_GROUP) == ERROR) {
-
-			nm_log(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, "Failed to drop privileges.  Aborting.");
-
-			cleanup();
-			exit(ERROR);
-		}
-
 		if (test_path_access(naemon_binary_path, X_OK)) {
 			nm_log(NSLOG_RUNTIME_ERROR, "Error: failed to access() %s: %s\n", naemon_binary_path, strerror(errno));
 			nm_log(NSLOG_RUNTIME_ERROR, "Error: Spawning workers will be impossible. Aborting.\n");
diff --git a/src/naemon/utils.c b/src/naemon/utils.c
index f270988..9f65c51 100644
--- a/src/naemon/utils.c
+++ b/src/naemon/utils.c
@@ -596,92 +596,6 @@ int daemon_init(void)
 	return OK;
 }
 
-
-/******************************************************************/
-/*********************** SECURITY FUNCTIONS ***********************/
-/******************************************************************/
-
-/* drops privileges */
-int drop_privileges(char *user, char *group)
-{
-	uid_t uid = -1;
-	gid_t gid = -1;
-	struct group *grp = NULL;
-	struct passwd *pw = NULL;
-	int result = OK;
-
-	/* only drop privileges if we're running as root, so we don't interfere with being debugged while running as some random user */
-	if (getuid() != 0)
-		return OK;
-
-	/* set effective group ID */
-	if (group != NULL) {
-
-		/* see if this is a group name */
-		if (strspn(group, "0123456789") < strlen(group)) {
-			grp = (struct group *)getgrnam(group);
-			if (grp != NULL)
-				gid = (gid_t)(grp->gr_gid);
-			else
-				nm_log(NSLOG_RUNTIME_WARNING, "Warning: Could not get group entry for '%s'", group);
-		}
-
-		/* else we were passed the GID */
-		else
-			gid = (gid_t)atoi(group);
-	}
-
-	/* set effective user ID */
-	if (user != NULL) {
-
-		/* see if this is a user name */
-		if (strspn(user, "0123456789") < strlen(user)) {
-			pw = (struct passwd *)getpwnam(user);
-			if (pw != NULL)
-				uid = (uid_t)(pw->pw_uid);
-			else
-				nm_log(NSLOG_RUNTIME_WARNING, "Warning: Could not get passwd entry for '%s'", user);
-		}
-
-		/* else we were passed the UID */
-		else
-			uid = (uid_t)atoi(user);
-	}
-
-	/* now that we know what to change to, we fix log file permissions */
-	fix_log_file_owner(uid, gid);
-
-	/* set effective group ID if other than current EGID */
-	if (gid != getegid()) {
-		if (setgid(gid) == -1) {
-			nm_log(NSLOG_RUNTIME_WARNING, "Warning: Could not set effective GID=%d", (int)gid);
-			result = ERROR;
-		}
-	}
-#ifdef HAVE_INITGROUPS
-
-	if (uid != geteuid()) {
-
-		/* initialize supplementary groups */
-		if (initgroups(user, gid) == -1) {
-			if (errno == EPERM)
-				nm_log(NSLOG_RUNTIME_WARNING, "Warning: Unable to change supplementary groups using initgroups() -- I hope you know what you're doing");
-			else {
-				nm_log(NSLOG_RUNTIME_WARNING, "Warning: Possibly root user failed dropping privileges with initgroups()");
-				return ERROR;
-			}
-		}
-	}
-#endif
-	if (setuid(uid) == -1) {
-		nm_log(NSLOG_RUNTIME_WARNING, "Warning: Could not set effective UID=%d", (int)uid);
-		result = ERROR;
-	}
-
-	return result;
-}
-
-
 /******************************************************************/
 /************************* FILE FUNCTIONS *************************/
 /******************************************************************/
