From 150064c6387e59dfa42206b9e7937362324c290c Mon Sep 17 00:00:00 2001
From: Sven Nierlein <sven@nierlein.de>
Date: Sat, 12 Jun 2021 14:32:57 +0200
Subject: [PATCH 1/2] POC vault macros and broker

this PR implements dynamic macro expansion from neb modules in order to
implement password vault broker neb modules. From naemons point of view, we
simply define a new macro prefix $VAULT...$ and add broker callbacks to fill
the value.

In order to make password vault work, we need enter a master password before
naemon starts, thats why closing stdin moved to after the neb module
initialization. So the neb module may implement reading something from stdin.

Advantage of this vault macros would be:

  - dynamic 3rd party macro expansion is not limited to passwords
  - password storage can be implemented in any way you like, ex. simply encrypted file or advanced remote vaults
  - vault macros are not limited to numbers like $VAULT1$ but can be anything ex.: $VAULTSNMPCOMMUNITY$
  - some context might be interesting during macro expansion, something like hostname, etc...
    thats why the macros *mac struct is passed to the broker which might contain host/service/contact pointer.

Things to be done:

  - master password is lost during reloads and stdin is closed at that point,
    so need to find a way to save the master password over reloads.
  - systemd integration needs to be tested (can stdin be used here)

Signed-off-by: Sven Nierlein <sven@nierlein.de>
---
 src/naemon/broker.c       | 24 ++++++++++++++++++++++++
 src/naemon/broker.h       |  4 +++-
 src/naemon/macros.c       |  5 +++++
 src/naemon/naemon.c       | 15 +++++++++++++++
 src/naemon/nebcallbacks.h |  1 +
 src/naemon/nebstructs.h   |  8 ++++++++
 src/naemon/utils.c        | 11 -----------
 7 files changed, 56 insertions(+), 12 deletions(-)

diff --git a/src/naemon/broker.c b/src/naemon/broker.c
index 81db929a..e24afaa4 100644
--- a/src/naemon/broker.c
+++ b/src/naemon/broker.c
@@ -919,3 +919,27 @@ void broker_statechange_data(int type, int flags, int attr, int statechange_type
 
 	return;
 }
+
+/* get vault macro from broker */
+int broker_vault_macro(char *macro_name, char **output, int *free_macro, nagios_macros *mac)
+{
+	nebstruct_vault_macro_data ds;
+
+	if (!(event_broker_options & BROKER_VAULT_MACROS))
+		return OK;
+
+	/* fill struct with relevant data */
+	ds.macro_name = macro_name;
+	ds.value      = NULL;
+	ds.mac        = mac;
+
+	/* make callbacks */
+	neb_make_callbacks(NEBCALLBACK_VAULT_MACRO_DATA, (void *)&ds);
+
+	if(ds.value != NULL) {
+		*free_macro = TRUE;
+		*output = ds.value;
+	}
+
+	return OK;
+}
diff --git a/src/naemon/broker.h b/src/naemon/broker.h
index 94b05fca..9ebe6b59 100644
--- a/src/naemon/broker.h
+++ b/src/naemon/broker.h
@@ -10,6 +10,7 @@
 #include "objects_contact.h"
 #include "objects_service.h"
 #include "nebmods.h"
+#include "macros.h"
 
 /*************** EVENT BROKER OPTIONS *****************/
 
@@ -27,7 +28,7 @@
 #define BROKER_COMMENT_DATA         	256	/* DONE */
 #define BROKER_DOWNTIME_DATA		512     /* DONE */
 #define BROKER_SYSTEM_COMMANDS          1024	/* DONE */
-#define BROKER_OCP_DATA_UNUSED          2048	/* reusable */
+#define BROKER_VAULT_MACROS             2048    /* DONE */
 #define BROKER_STATUS_DATA              4096    /* DONE */
 #define BROKER_ADAPTIVE_DATA            8192    /* DONE */
 #define BROKER_EXTERNALCOMMAND_DATA     16384   /* DONE */
@@ -191,6 +192,7 @@ void broker_aggregated_status_data(int, int, int);
 void broker_retention_data(int, int, int);
 void broker_acknowledgement_data(int, int, int, int, void *, char *, char *, int, int, int);
 void broker_statechange_data(int, int, int, int, void *, int, int, int, int);
+int broker_vault_macro(char *, char **, int *, nagios_macros *);
 
 NAGIOS_END_DECL
 #endif
diff --git a/src/naemon/macros.c b/src/naemon/macros.c
index 8546354a..66422304 100644
--- a/src/naemon/macros.c
+++ b/src/naemon/macros.c
@@ -7,6 +7,7 @@
 #include "logging.h"
 #include "globals.h"
 #include "nm_alloc.h"
+#include "broker.h"
 #include <string.h>
 #include <glib.h>
 
@@ -2144,6 +2145,10 @@ static int grab_macro_value_r(nagios_macros *mac, char *macro_buffer, char **out
 		return OK;
 	}
 
+	if (strstr(macro_buffer, "VAULT") == macro_buffer) {
+		return(broker_vault_macro(macro_buffer, output, free_macro, mac));
+	}
+
 	/* most frequently used "x" macro gets a shortcut */
 	if (mac->host_ptr && !strcmp(macro_buffer, "HOSTADDRESS")) {
 		if (mac->host_ptr->address)
diff --git a/src/naemon/naemon.c b/src/naemon/naemon.c
index 4aa05b7e..86d26ee2 100644
--- a/src/naemon/naemon.c
+++ b/src/naemon/naemon.c
@@ -27,6 +27,7 @@
 
 #include <getopt.h>
 #include <string.h>
+#include <fcntl.h>
 
 static int test_path_access(const char *program, int mode)
 {
@@ -579,6 +580,20 @@ int main(int argc, char **argv)
 		}
 		timing_point("Loaded modules\n");
 
+		/* close stdin after the neb modules loaded so they can still ask for passwords */
+		if (daemon_mode == TRUE && sigrestart == FALSE) {
+			/* close existing stdin, stdout, stderr */
+			close(0);
+			close(1);
+			close(2);
+
+			/* THIS HAS TO BE DONE TO AVOID PROBLEMS WITH STDERR BEING REDIRECTED TO SERVICE MESSAGE PIPE! */
+			/* re-open stdin, stdout, stderr with known values */
+			open("/dev/null", O_RDONLY);
+			open("/dev/null", O_WRONLY);
+			open("/dev/null", O_WRONLY);
+		}
+
 		timing_point("Making first callback\n");
 		broker_program_state(NEBTYPE_PROCESS_PRELAUNCH, NEBFLAG_NONE, NEBATTR_NONE);
 		timing_point("Made first callback\n");
diff --git a/src/naemon/nebcallbacks.h b/src/naemon/nebcallbacks.h
index 2b79c5b5..8ed700c5 100644
--- a/src/naemon/nebcallbacks.h
+++ b/src/naemon/nebcallbacks.h
@@ -36,6 +36,7 @@ enum NEBCallbackType {
 	NEBCALLBACK_STATE_CHANGE_DATA,
 	NEBCALLBACK_CONTACT_STATUS_DATA,
 	NEBCALLBACK_ADAPTIVE_CONTACT_DATA,
+	NEBCALLBACK_VAULT_MACRO_DATA,
 	NEBCALLBACK_TYPE__COUNT
 };
 
diff --git a/src/naemon/nebstructs.h b/src/naemon/nebstructs.h
index 86e3ac08..68f701e0 100644
--- a/src/naemon/nebstructs.h
+++ b/src/naemon/nebstructs.h
@@ -6,6 +6,7 @@
 #endif
 
 #include "common.h"
+#include "macros.h"
 
 NAGIOS_BEGIN_DECL
 
@@ -490,5 +491,12 @@ typedef struct nebstruct_statechange_struct {
 	void            *object_ptr;
 } nebstruct_statechange_data;
 
+/* vault macro retrieve structure */
+typedef struct nebstruct_vault_macro_struct {
+	char            *macro_name;
+	char            *value;
+	nagios_macros   *mac;
+} nebstruct_vault_macro_data;
+
 NAGIOS_END_DECL
 #endif
diff --git a/src/naemon/utils.c b/src/naemon/utils.c
index b36393f8..4db5aa17 100644
--- a/src/naemon/utils.c
+++ b/src/naemon/utils.c
@@ -637,17 +637,6 @@ int daemon_init(void)
 	val |= FD_CLOEXEC;
 	fcntl(lockfile, F_SETFD, val);
 
-	/* close existing stdin, stdout, stderr */
-	close(0);
-	close(1);
-	close(2);
-
-	/* THIS HAS TO BE DONE TO AVOID PROBLEMS WITH STDERR BEING REDIRECTED TO SERVICE MESSAGE PIPE! */
-	/* re-open stdin, stdout, stderr with known values */
-	open("/dev/null", O_RDONLY);
-	open("/dev/null", O_WRONLY);
-	open("/dev/null", O_WRONLY);
-
 	broker_program_state(NEBTYPE_PROCESS_DAEMONIZE, NEBFLAG_NONE, NEBATTR_NONE);
 
 	return OK;

From ca9acaa8a53ac7afb26dae852007a485b97e15e0 Mon Sep 17 00:00:00 2001
From: Sven Nierlein <sven@nierlein.de>
Date: Wed, 16 Jun 2021 14:06:05 +0200
Subject: [PATCH 2/2] add global persistant broker storage

This PR adds a global key/value storage which is persitant over reloads (but not restarts).
The storage could be used from neb modules to store data over reloads like this:

```c
// fetch global storage
struct kvvec *global_store = get_global_store();

// store string value
kvvec_addkv_str(global_store, "example_key", (char *)mkstr("%s", "example string value"));

// read string from storage
char *persistant = kvvec_fetch_str_str(global_store, "example_key");
```

Signed-off-by: Sven Nierlein <sven@nierlein.de>
---
 src/naemon/broker.c | 6 ++++++
 src/naemon/broker.h | 1 +
 src/naemon/naemon.c | 6 ++++++
 3 files changed, 13 insertions(+)

diff --git a/src/naemon/broker.c b/src/naemon/broker.c
index e24afaa4..a1b950c4 100644
--- a/src/naemon/broker.c
+++ b/src/naemon/broker.c
@@ -12,6 +12,12 @@
 #include <string.h>
 #include <sys/time.h>
 
+static struct kvvec global_store = KVVEC_INITIALIZER;
+
+struct kvvec *get_global_store(void)
+{
+	return &global_store;
+}
 
 /* gets timestamp for use by broker */
 static inline void get_broker_timestamp(struct timeval *timestamp)
diff --git a/src/naemon/broker.h b/src/naemon/broker.h
index 9ebe6b59..47cc7ace 100644
--- a/src/naemon/broker.h
+++ b/src/naemon/broker.h
@@ -167,6 +167,7 @@
 
 NAGIOS_BEGIN_DECL
 
+struct kvvec *get_global_store(void);
 void broker_program_state(int, int, int);
 void broker_log_data(int, int, int, char *, unsigned long, time_t);
 int broker_event_handler(int, int, int, int, void *, int, int, struct timeval, struct timeval, double, int, int, int, char *, char *, char *);
diff --git a/src/naemon/naemon.c b/src/naemon/naemon.c
index 86d26ee2..04edc4a8 100644
--- a/src/naemon/naemon.c
+++ b/src/naemon/naemon.c
@@ -135,6 +135,7 @@ int main(int argc, char **argv)
 	nagios_macros *mac;
 	const char *worker_socket = NULL;
 	int i;
+	struct kvvec *global_store;
 
 #ifdef HAVE_GETOPT_H
 	int option_index = 0;
@@ -227,6 +228,11 @@ int main(int argc, char **argv)
 	                                        G_LOG_FLAG_RECURSION, nm_g_log_handler, NULL);
 	mac = get_global_macros();
 
+	global_store = get_global_store();
+	if (global_store && !kvvec_init(global_store, 0)) {
+		exit(ERROR);
+	}
+
 	/* if we're a worker we can skip everything below */
 	if (worker_socket) {
 		exit(nm_core_worker(worker_socket));
